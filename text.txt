/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   minishell.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/17 15:23:33 by lidbaha           #+#    #+#             */
/*   Updated: 2025/05/17 20:34:14 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	main(int ac, char **av, char **envp)
{
	char	*line;
	t_env	*env;
	int		last_status;

	env = cpy_env(envp);
	last_status = 0;
	if (ac > 1)
	{
		printf("error, don't entry argument");
		return (0);
	}
	(void)av;
	while (1)
	{
		line = readline("Minishell:~$ ");
		add_history(line);
		last_status = parse_v2(line, env, last_status);
		free(line);
	}
	(void)env;
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   minishell.h                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/17 15:23:31 by lidbaha           #+#    #+#             */
/*   Updated: 2025/05/17 20:34:09 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef MINISHELL_H
# define MINISHELL_H

# include <stdio.h>
# include <unistd.h>
# include <stdbool.h>
# include <readline/history.h>
# include <readline/readline.h>
# include "../includes/libft/libft.h"
# include "../includes/get_next_line/get_next_line.h"
# include <sys/types.h>
# include <sys/wait.h>

# define LL_MAX			9223372036854775807ULL
# define ERR_NUM_EXIT	"minishell: exit: numeric argument required\n"
# define ERR_ARG_EXIT	"minishell: exit: too many arguments\n"
# define SUCCESS 		0
# define FAIL 			1
# define CODE_FAIL 		1
# define CODE_SUCCESS	0
# define NO_QUOTE		0
# define S_QUOTE		1
# define D_QUOTE		2

typedef enum e_token_type
{
	WORD,				// word
	PIPE,				// when find a |
	REDIRECT_IN,		// when find <
	REDIRECT_OUT,		// >
	REDIRECT_APPEND,	// >>
	HEREDOC,			// <<
}							t_token_type;

typedef struct s_token
{
	char					*value;
	t_token_type			type;
	struct s_token			*next;
}							t_token;

typedef struct s_redir
{
	t_token_type			type;
	char					*file;
	struct s_redir			*next;
}							t_redir;

/* structure pour l'exécution */
typedef struct s_cmd
{
	char					**args;
	t_redir					*infile;
	t_redir					*outfile;
	bool					builtin;
	struct s_cmd			*next;
}							t_cmd;

/* une fois que je suis dans les forks : d'abord les redirections → les $
	→ le split sur les espaces → gestion des guillemets*/
typedef struct s_env
{
	char					*key;
	char					*value;
	struct s_env			*next;
}							t_env;

typedef struct s_shell
{
	t_env					**env;
	t_cmd					**cmd;
	int						exit_status;
}							t_shell;

typedef struct t_parse_space
{
	char					**line;
}							t_parse_space;

typedef struct s_parse_pipe
{
	char					**line;
}							t_parse_pipe;

typedef struct s_parse_redir_input
{
	char					**line;
}							t_parse_redir_input;

typedef struct s_parse_redir_output
{
	char					**line;
}							t_parse_redir_output;

typedef struct s_parse_redir_append
{
	char					**line;
}							t_parse_redir_append;

typedef struct s_parse_redir_heredoc
{
	char					**line;
}							t_parse_redir_heredoc;

typedef struct s_parse
{
	char					*line;
	t_parse_space			*space;
	t_parse_pipe			*pipe;
	t_parse_redir_input		*redir_input;
	t_parse_redir_output	*redir_output;
	t_parse_redir_append	*redir_append;
	t_parse_redir_heredoc	*redir_heredoc;
}							t_parse;

typedef struct s_quotes
{
	int						index;
	char					*line;
	struct s_quotes			*next;
}							t_quotes;

typedef struct s_info
{
	int						space;
	int						pipe;
	int						redir_input;
	int						redir_output;
	int						redir_append;
	int						redir_heredoc;
}							t_info;

typedef struct s_parse_redir
{
	char					**line;
	struct s_parse_redir	*next;
}							t_parse_redir;

/* parsing */
t_cmd						*init_cmd(void);
t_parse_redir				*init_redir(void);
void						parse(char *line);
int							parse_v2(char *line, t_env *env, int last_status);
void						fill_t_cmd(t_parse_redir *redir, t_cmd *cmd);
void						parse_pipe(t_parse *cmd, char *line);
char						**ft_divide_char(char *line, char sep);
char						**ft_divide_str(char *line, char *sep);
void						parse_redir_input(t_parse *cmd, char *line);
void						parse_redir_output(t_parse *cmd, char *line);
void						parse_redir_append(t_parse *cmd, char *line);
void						parse_redir(t_parse_redir *redir, char **pipe);
void						parse_redir_heredoc(t_parse *cmd, char *line);

/* quotes */
char						*skip_quotes(char *line, char quote);
char						*remove_quotes(char *line, t_quotes *quotes);
void						replace_quotes(t_parse *cmd, t_quotes *quotes);
int							check_quote_closed(char *line, int index, char quote);

/* split */
void						free_tab(char **tab, int y);
char						**ft_minishell_split_str(const char *s, char *sep);
char						**ft_minishell_split_char(const char *s, char sep);

/* cleaning */
void						clean_env(void);
void						clean_pipe(char **pipe);
void						clean_cmd(t_parse *cmd);
void						clean_split(char **split);
void						clean_quotes(t_quotes *quotes);
void						clean_redir(t_parse_redir *redir);

/* utils */
char						**ft_strdup_split(char **split);

/* utils built-in */
int							name_var_valid(char *str);

/* handle environnement */
t_env						*cpy_env(char **env);
char						*get_before_egal(char *str);
char						*get_after_egal(char *str);

/* Handle expand var and trim quotes */
void    					expand_and_trim_cmd(t_cmd *cmd, t_env *env, int last_status);
void						handling_dollars(t_cmd *cmd, t_env *env, int last_status);
void						expand_arg(char **arg, t_env *env, int last_status, int *index);
int							check_expand_quote(int *quote, char c);
void    					trim_quotes(t_cmd *cmd);
void    					find_and_trim_quote(char **arg);

/* Handle here doc, return name file */
char	*get_here_doc(char *str);

/* built-in */
int		ft_pwd(void);
int		ft_echo(t_cmd *cmd);
int		ft_cd(t_env **env, t_cmd *cmd);
int		ft_env(t_env *env, t_cmd *cmd);
int		ft_unset(t_cmd *cmd, t_env **env);
int		ft_export(t_env **env, t_cmd *cmd);
int		ft_exit(t_cmd *cmd, int exit_status);

/* error message during executing */
void	error_message(char *str);
void	is_a_directory(char *str);
void	command_not_found(char *cmd);
void	permission_denied(char *file);
void	no_such_file_or_directory(char *cmd);

/* executing */
int		ft_exec(t_cmd *cmd, t_env *env, int exit_code);
int		is_special_built_in(char *cmd);
int		executing_special_built_in(t_cmd *cmd, t_env *env);

/* build env for execution */
char	**env_tab_char(t_env *env);

/* process */
int		ft_process(t_cmd *cmd, t_env *env, int *pipe_fd, int prev_fd);

/* find command */
char	*find_cmd_path(t_env *env, t_cmd *cmd);

/* management of redirection for infile or outfile */
int		last_outfile(t_cmd *cmd);
int		last_infile(t_cmd *cmd);
int		redirect_management(t_cmd *cmd, int *pipe_fd, int prev_fd);

/* handle free execution */
void	free_t_cmd(t_cmd *cmd);
void	free_tab_char(char **tab);
void	free_t_redir(t_redir *list);
int		ft_exit_exec(int exit_code, t_cmd *cmd, char **envp, char *path_cmd);

/* built-in utils */
int	    count_tab_char(char **tab);
char	*get_before_egal(char *str);
char	*get_after_egal(char *str);
int		is_built_in(char *str);
int		name_var_valid(char *str);

#endif/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_atoi.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/21 14:19:37 by tmillot           #+#    #+#             */
/*   Updated: 2024/10/21 14:48:32 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_atoi(const char *nptr)
{
	int	sign;
	int	result;
	int	i;

	sign = 1;
	result = 0;
	i = 0;
	while ((nptr[i] >= 9 && nptr[i] <= 13) || nptr[i] == 32)
		i++;
	if (nptr[i] == '+' || nptr[i] == '-')
	{
		if (nptr[i] == '-')
			sign *= -1;
		i++;
	}
	while (nptr[i] >= '0' && nptr[i] <= '9')
	{
		result = result * 10 + (nptr[i] - '0');
		i++;
	}
	return (sign * result);
}

/*int main(int argc, char **argv)
{
	(void)argc;
	printf("%d\n", atoi(argv[1]));
	printf("%d", ft_atoi(argv[1]));
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_bzero.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/15 16:41:28 by tmillot           #+#    #+#             */
/*   Updated: 2024/10/17 11:33:50 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_bzero(void *s, size_t n)
{
	unsigned char	*dest;

	dest = (unsigned char *)s;
	while (n > 0)
	{
		*dest++ = 0;
		n--;
	}
}

/*int main(int argc, char **argv)
{
	(void)argc;
	char str[100];
	strncpy(str, argv[1], sizeof(str));
	str[sizeof(str) - 1] = '\0';

	printf("Original: %s\n", str); 
	size_t i = 0;
	size_t len = ft_strlen(str);
	ft_bzero(str, 2);
	while (i < len)
	{
		printf("%c", str[i]);
		i++;
	}
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_calloc.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/21 14:51:35 by tmillot           #+#    #+#             */
/*   Updated: 2024/10/22 13:19:40 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	*ft_calloc(size_t nmemb, size_t size)
{
	char	*ptr;

	ptr = malloc(nmemb * size);
	if (ptr)
		ft_bzero(ptr, (nmemb * size));
	return (ptr);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isalnum.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/14 18:18:04 by tmillot           #+#    #+#             */
/*   Updated: 2024/10/24 20:34:31 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_isalnum(int c)
{
	if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')
		|| (c >= '0' && c <= '9'))
		return (1);
	return (0);
}

/*#include <stdio.h>

int main(int argc, char **argv)
{
	(void)argc;
	printf("%d", ft_isalnum(argv[1][0]));
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isalpha.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/14 15:22:29 by tmillot           #+#    #+#             */
/*   Updated: 2024/10/24 20:35:46 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_isalpha(int c)
{
	if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'))
		return (1);
	return (0);
}

/*#include <stdio.h>
#include <stdlib.h>

int main(int argc, char **argv)
{
	(void)argc;
	printf("%d", ft_isalpha((argv[1][0])));
}*//* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isascii.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/15 11:50:50 by tmillot           #+#    #+#             */
/*   Updated: 2024/10/24 20:36:32 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_isascii(int c)
{
	if (c >= 0 && c <= 127)
		return (1);
	return (0);
}

/*#include <stdio.h>

int main(int argc, char **argv)
{
    (void)argc;
    printf("%d\n", ft_isascii(argv[1][0]));
}*//* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isdigit.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/14 18:01:29 by tmillot           #+#    #+#             */
/*   Updated: 2024/10/24 20:36:49 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_isdigit(int c)
{
	if (c >= '0' && c <= '9')
		return (1);
	return (0);
}

/*#include <stdio.h>

int main(int argc, char **argv)
{
	(void)argc;
	printf("%d", ft_isdigit(argv[1][0]));
}*//* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isprint.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/15 13:21:29 by tmillot           #+#    #+#             */
/*   Updated: 2024/10/24 20:37:35 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_isprint(int c)
{
	if (c >= 32 && c <= 126)
		return (1);
	return (0);
}

/*#include <stdio.h>

int main(int argc, char **argv)
{
	(void)argc;
	printf("%d", ft_isprint(argv[1][0]));
}*//* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_itoa.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/24 13:05:04 by tmillot           #+#    #+#             */
/*   Updated: 2024/10/26 19:10:08 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

static int	count_nbr(int n)
{
	int	count;

	count = 0;
	if (n <= 0)
		count = 1;
	while (n != 0)
	{
		n = n / 10;
		count++;
	}
	return (count);
}

char	*ft_itoa(int n)
{
	char	*str;
	int		len;
	long	nbr;

	nbr = n;
	len = count_nbr(nbr);
	str = malloc((len + 1) * sizeof(char));
	if (!str)
		return (NULL);
	if (nbr < 0)
	{
		nbr *= -1;
		str[0] = '-';
	}
	str[len] = '\0';
	while (--len >= (n < 0))
	{
		str[len] = (nbr % 10) + '0';
		nbr = nbr / 10;
	}
	return (str);
}

/*int main(void)
{
	printf("%s", ft_itoa(2147483647));
}*//* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstadd_back_bonus.c                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/27 11:59:37 by tmillot           #+#    #+#             */
/*   Updated: 2024/10/27 15:07:36 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_lstadd_back(t_list **lst, t_list *new)
{
	t_list	*last;

	if (lst == NULL || new == NULL)
		return ;
	if (*lst == NULL)
	{
		*lst = new;
		return ;
	}
	last = *lst;
	while (last->next != NULL)
		last = last->next;
	last->next = new;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstadd_front_bonus.c                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/27 09:55:21 by tmillot           #+#    #+#             */
/*   Updated: 2024/10/27 10:39:41 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_lstadd_front(t_list **lst, t_list *new)
{
	new->next = *lst;
	*lst = new;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstclear_bonus.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/27 12:45:51 by tmillot           #+#    #+#             */
/*   Updated: 2024/10/27 15:12:11 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_lstclear(t_list **lst, void (*del)(void *))
{
	t_list	*tmp;

	while (*lst)
	{
		tmp = (*lst)->next;
		ft_lstdelone(*lst, del);
		*lst = tmp;
	}
	free(*lst);
	*lst = NULL;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstdelone_bonus.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/27 12:34:30 by tmillot           #+#    #+#             */
/*   Updated: 2024/10/27 12:44:38 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_lstdelone(t_list *lst, void (*del)(void *))
{
	del(lst->content);
	free(lst);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstiter_bonus.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/27 14:00:37 by tmillot           #+#    #+#             */
/*   Updated: 2024/10/27 15:29:09 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_lstiter(t_list *lst, void (*f)(void *))
{
	while (lst)
	{
		f(lst->content);
		lst = lst->next;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstlast_bonus.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/27 11:27:45 by tmillot           #+#    #+#             */
/*   Updated: 2024/10/27 14:48:29 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

t_list	*ft_lstlast(t_list *lst)
{
	if (lst == NULL)
		return (NULL);
	while (lst->next != NULL)
		lst = lst->next;
	return (lst);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstmap_bonus.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/27 14:16:22 by tmillot           #+#    #+#             */
/*   Updated: 2024/10/27 16:01:26 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

t_list	*ft_lstmap(t_list *lst, void *(*f)(void *), void (*del)(void *))
{
	t_list	*dest;
	t_list	*tmp;
	void	*content;

	if (!lst || !f)
		return (NULL);
	dest = NULL;
	while (lst)
	{
		content = f(lst->content);
		tmp = ft_lstnew(content);
		if (!tmp)
		{
			if (content)
				del(content);
			ft_lstclear(&dest, del);
			return (NULL);
		}
		ft_lstadd_back(&dest, tmp);
		lst = lst->next;
	}
	return (dest);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstnew_bonus.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/27 08:42:21 by tmillot           #+#    #+#             */
/*   Updated: 2024/10/27 09:51:25 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

t_list	*ft_lstnew(void *content)
{
	t_list	*dest;

	dest = malloc(sizeof(t_list));
	if (!dest)
		return (NULL);
	dest->content = content;
	dest->next = NULL;
	return (dest);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstsize_bonus.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/27 10:43:15 by tmillot           #+#    #+#             */
/*   Updated: 2024/10/27 11:25:40 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_lstsize(t_list *lst)
{
	int	size;

	size = 0;
	while (lst)
	{
		size++;
		lst = lst->next;
	}
	return (size);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memchr.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/21 09:47:10 by tmillot           #+#    #+#             */
/*   Updated: 2024/10/26 17:05:15 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	*ft_memchr(const void *s, int c, size_t n)
{
	unsigned char	*src;
	size_t			i;

	src = (unsigned char *)s;
	i = 0;
	while (i < n)
	{
		if (src[i] == (unsigned char)c)
			return ((void *)&src[i]);
		i++;
	}
	return (NULL);
}

/*int main(int argc, char **argv)
{
	(void)argc;
    printf("%s\n", (char *)memchr(argv[1], argv[2][0], atoi(argv[3])));
    printf("%s\n", (char *)ft_memchr(argv[1], argv[2][0], atoi(argv[3])));
}*//* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memcmp.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/21 11:04:24 by tmillot           #+#    #+#             */
/*   Updated: 2024/10/26 17:10:49 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_memcmp(const void *s1, const void *s2, size_t n)
{
	size_t			i;
	unsigned char	*p1;
	unsigned char	*p2;

	p1 = (unsigned char *)s1;
	p2 = (unsigned char *)s2;
	i = 0;
	while (i < n)
	{
		if (p1[i] != p2[i])
			return (p1[i] - p2[i]);
		i++;
	}
	return (0);
}

/*int main(int argc, char **argv)
{
    (void)argc;
    printf("%d\n", memcmp(argv[1], argv[2], atoi(argv[3])));
    printf("%d", ft_memcmp(argv[1], argv[2], atoi(argv[3])));
}*//* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memcpy.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/16 11:24:34 by tmillot           #+#    #+#             */
/*   Updated: 2024/10/16 13:55:22 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	*ft_memcpy(void *dest, const void *src, size_t n)
{
	unsigned char		*d;
	const unsigned char	*s;

	d = (unsigned char *)dest;
	s = (const unsigned char *)src;
	if (dest == NULL && src == NULL)
		return (NULL);
	while (n > 0)
	{
		*d++ = *s++;
		n--;
	}
	return (dest);
}

/*int main(int argc, char **argv)
{
	(void)argc;
	printf("dest origin :%s\n source origin :%s\n", argv[1], argv[2]);
	ft_memcpy(argv[1], argv[2], atoi(argv[3]));
	printf("dest after ft_memcpy : %s\n", argv[1]);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memmove.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/16 14:00:45 by tmillot           #+#    #+#             */
/*   Updated: 2024/10/16 16:38:38 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	*ft_memmove(void *dest, const void *src, size_t n)
{
	unsigned char		*d;
	const unsigned char	*s;

	d = (unsigned char *)dest;
	s = (const unsigned char *)src;
	if (dest == NULL && src == NULL)
		return (NULL);
	if (d > s)
	{
		while (n-- > 0)
			d[n] = s[n];
	}
	else
	{
		while (n-- > 0)
			*d++ = *s++;
	}
	return (dest);
}

/*int main(int argc, char **argv)
{
	(void)argc;
	printf("dest origin :%s\n source origin :%s\n", argv[1], argv[2]);
	ft_memmove(argv[1], argv[2], atoi(argv[3]));
	printf("dest after ft_memmove : %s\n", argv[1]);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memset.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/15 15:17:43 by tmillot           #+#    #+#             */
/*   Updated: 2024/10/16 17:30:03 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	*ft_memset(void *s, int c, size_t n)
{
	unsigned char	*dest;

	dest = (unsigned char *)s;
	while (n > 0)
	{
		*dest++ = (unsigned char)c;
		n--;
	}
	return (s);
}

/*int main(int argc, char **argv)
{
	(void)argc;
	ft_memset(argv[1], argv[2][0], 5);
	printf("%s", argv[1]);
}*//* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_printf.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/15 14:32:24 by toto              #+#    #+#             */
/*   Updated: 2025/05/12 17:43:38 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_parse_printf(const char *str, va_list args, int *count)
{
	int	i;

	i = 0;
	while (str[i] != '\0')
	{
		if (str[i] == '%')
			ft_check_option(str[++i], args, count);
		else
		{
			ft_putchar(str[i]);
			(*count)++;
		}
		i++;
	}
}

void	ft_check_option(char c, va_list args, int *count)
{
	if (c == 'c')
	{
		ft_putchar((char)va_arg(args, int));
		(*count)++;
	}
	else if (c == 's')
		ft_putstr_count(va_arg(args, char *), count);
	else if (c == 'p')
		ft_print_pointer(va_arg(args, unsigned long), count);
	else if (c == 'd')
		ft_putnbr_count(va_arg(args, int), count);
	else if (c == 'i')
		ft_putnbr_count(va_arg(args, int), count);
	else if (c == 'x')
		ft_putnbr_hexa_lowercase(va_arg(args, int), count);
	else if (c == 'X')
		ft_putnbr_hexa_uppercase(va_arg(args, int), count);
	else if (c == 'u')
		ft_putnbr_count_unsigned(va_arg(args, unsigned int), count);
	else if (c == '%')
	{
		ft_putchar('%');
		(*count)++;
	}
}

int	ft_printf(const char *str, ...)
{
	va_list	args;
	int		count;

	va_start(args, str);
	count = 0;
	ft_parse_printf(str, args, &count);
	va_end(args);
	return (count);
}

// void main()
// {
// 	printf("size : %d \n", ft_printf(" %x ", -1));
// 	printf("size : %d", printf(" %x ", -1));
// }/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_print_pointer.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/16 20:39:05 by toto              #+#    #+#             */
/*   Updated: 2025/05/12 17:43:34 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_print_pointer(unsigned long ptr, int *count)
{
	const char		*hexa;
	char			stock[16];
	int				i;

	hexa = "0123456789abcdef";
	i = 0;
	if (!ptr)
		(*count) += write(1, "(nil)", 5);
	if (ptr != 0)
	{
		while (ptr > 0)
		{
			stock[i++] = hexa[ptr % 16];
			ptr = ptr / 16;
		}
		(*count) += write(1, "0x", 2);
		while (i > 0)
			(*count) += write(1, &stock[--i], 1);
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putchar_fd.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/24 19:33:29 by tmillot           #+#    #+#             */
/*   Updated: 2024/10/24 19:48:55 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_putchar_fd(char c, int fd)
{
	write(fd, &c, 1);
}

/*int main(int argc, char **argv)
{
	(void)argc;
	ft_putchar_fd(argv[1][0], 1);
}*//* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putendl_fd.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/24 20:05:32 by tmillot           #+#    #+#             */
/*   Updated: 2024/10/24 20:15:01 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_putendl_fd(char *s, int fd)
{
	int	i;

	i = 0;
	while (s[i] != '\0')
		write(fd, &s[i++], 1);
	write(fd, "\n", 1);
}

/*int main(int argc, char **argv)
{
	(void)argc;
	ft_putendl_fd(argv[1], 1);
	ft_putendl_fd(argv[2], 1);
}*//* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putnbr_count.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/17 19:18:51 by toto              #+#    #+#             */
/*   Updated: 2025/05/12 17:43:41 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_putnbr_count(int n, int *count)
{
	if (n == -2147483648)
	{
		(*count) += write(1, "-", 1);
		(*count) += write(1, "2", 1);
		n = 147483648;
	}
	if (n < 0)
	{
		(*count) += write(1, "-", 1);
		n *= -1;
	}
	if (n >= 10)
		ft_putnbr_count(n / 10, count);
	n = (n % 10) + '0';
	(*count) += write(1, &n, 1);
}

void	ft_putnbr_count_unsigned(unsigned int n, int *count)
{
	if (n >= 10)
		ft_putnbr_count_unsigned(n / 10, count);
	n = (n % 10) + '0';
	(*count) += write(1, &n, 1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putnbr_fd.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/24 20:17:28 by tmillot           #+#    #+#             */
/*   Updated: 2024/10/26 17:22:11 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_putnbr_fd(int n, int fd)
{
	if (n == -2147483648)
	{
		write(fd, "-", 1);
		write(fd, "2", 1);
		n = 147483648;
	}
	if (n < 0)
	{
		write(fd, "-", 1);
		n *= -1;
	}
	if (n >= 10)
		ft_putnbr_fd(n / 10, fd);
	n = (n % 10) + '0';
	write(fd, &n, 1);
}

/*int main(int argc, char **argv)
{
	(void)argc;
	ft_putnbr_fb(atoi(argv[1]), 1);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putnbr_hexa.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/17 19:32:36 by toto              #+#    #+#             */
/*   Updated: 2025/05/12 17:43:45 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_putnbr_hexa_lowercase(int nb, int *count)
{
	const char			*base_hexa;
	int					i;
	char				stock[16];
	unsigned int		n;

	n = nb;
	i = 0;
	base_hexa = "0123456789abcdef";
	if (n == 0)
		(*count) += write(1, "0", 1);
	while (n > 0)
	{
		stock[i++] = base_hexa[n % 16];
		n = n / 16;
	}
	while (i > 0)
		(*count) += write(1, &stock[--i], 1);
}

void	ft_putnbr_hexa_uppercase(int nb, int *count)
{
	const char			*base_hexa;
	int					i;
	char				stock[16];
	unsigned int		n;

	n = nb;
	i = 0;
	base_hexa = "0123456789ABCDEF";
	if (n == 0)
		(*count) += write(1, "0", 1);
	while (n > 0)
	{
		stock[i++] = base_hexa[n % 16];
		n = n / 16;
	}
	while (i > 0)
		(*count) += write(1, &stock[--i], 1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putstr_count.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/16 18:16:33 by toto              #+#    #+#             */
/*   Updated: 2025/05/12 17:43:49 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_putstr_count(char *str, int *count)
{
	int	i;

	i = 0;
	if (str == NULL)
		(*count) += write(1, "(null)", 6);
	while (str != NULL && str[i] != '\0')
	{
		(*count) += write(1, &str[i], 1);
		i++;
	}
}

void	ft_putchar(char c)
{
	write(1, &c, 1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putstr_fd.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/24 19:52:26 by tmillot           #+#    #+#             */
/*   Updated: 2024/10/24 20:00:00 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_putstr_fd(char *s, int fd)
{
	int	i;

	i = 0;
	while (s[i] != '\0')
		write(fd, &s[i++], 1);
}

/*int main(int argc, char **argv)
{
	(void)argc;
	ft_putstr_fd(argv[1], 1);
}*//* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_split.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/24 11:17:22 by tmillot           #+#    #+#             */
/*   Updated: 2024/10/26 19:45:09 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

#include "libft.h"

static int	count_word(const char *s, char c)
{
	int	i;
	int	count;

	i = 0;
	count = 0;
	while (s[i] != '\0')
	{
		while (s[i] == c)
			i++;
		if (s[i] != '\0' && s[i] != c)
		{
			while (s[i] != '\0' && s[i] != c)
				i++;
			count++;
		}
	}
	return (count);
}

static char	*copy_str(const char *s, int start, int end)
{
	char	*str;

	str = ft_substr(s, start, (end - start));
	return (str);
}

static void	free_tab(char **tab, int y)
{
	while (y >= 0)
	{
		free(tab[y]);
		y--;
	}
	free(tab);
}

static int	ft_copy_str_tab(char **tab, const char *s, char c, int start)
{
	int	i;
	int	y;

	i = 0;
	y = 0;
	while (s[i] != '\0')
	{
		while (s[i] == c)
			i++;
		start = i;
		while (s[i] != '\0' && s[i] != c)
			i++;
		if (i > start)
		{
			tab[y] = copy_str(s, start, i);
			if (!tab[y])
			{
				free_tab(tab, y - 1);
				return (0);
			}
			y++;
		}
	}
	tab[y] = NULL;
	return (1);
}

char	**ft_split(const char *s, char c)
{
	char	**tab;

	if (!s)
		return (NULL);
	tab = malloc((count_word(s, c) + 1) * sizeof(char *));
	if (!tab)
		return (NULL);
	if (!ft_copy_str_tab(tab, s, c, 0))
		return (NULL);
	return (tab);
}

/*int main(int argc, char **argv)
{
	(void)argc;
	char **tab = ft_split(argv[1], argv[2][0]);
 	int i = 0;
	while (tab[i] != NULL)
	{
		printf("%s\n", tab[i]);
		i++;
	}
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strchr.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/18 10:52:36 by tmillot           #+#    #+#             */
/*   Updated: 2024/10/22 15:15:05 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

char	*ft_strchr(const char *s, int c)
{
	int	i;

	i = 0;
	while (s[i] != '\0' && s[i] != (char)c)
		i++;
	if (s[i] == (char)c)
		return ((char *)&s[i]);
	return (NULL);
}

/*int main(int argc, char **argv)
{
	(void)argc;
	printf("%s\n", strchr(argv[1], argv[2][0]));
	printf("%s", ft_strchr(argv[1], argv[2][0]));
}*//* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strcmp.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: thomas <thomas@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/19 10:13:57 by lidbaha           #+#    #+#             */
/*   Updated: 2025/03/21 13:50:39 by thomas           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_strcmp(const char *s1, const char *s2)
{
	size_t	i;

	i = 0;
	while (s1[i] == s2[i] && s1[i] && s2[i])
		i++;
	return ((unsigned char)s1[i] - (unsigned char)s2[i]);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strdup.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/21 15:21:15 by tmillot           #+#    #+#             */
/*   Updated: 2024/10/21 15:48:56 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

char	*ft_strdup(const char *s)
{
	char	*dup;
	int		i;

	i = 0;
	dup = malloc(ft_strlen(s) * sizeof(char) + 1);
	if (!dup)
		return (0);
	while (s[i])
	{
		dup[i] = s[i];
		i++;
	}
	dup[i] = '\0';
	return (dup);
}

/*int main(int argc, char **argv)
{
	(void)argc;
	printf("%s", ft_strdup((const char *)argv[1]));
}*//* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_striteri.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/24 16:47:56 by tmillot           #+#    #+#             */
/*   Updated: 2024/10/24 19:25:06 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_striteri(char *s, void (*f)(unsigned int, char*))
{
	unsigned int	i;

	i = 0;
	while (s[i] != '\0')
	{
		(*f)(i, &s[i]);
		i++;
	}
}

/*void to_uppercase(unsigned int index, char c) 
{
    (void)index;
    if (c >= 'a' && c <= 'z')
        c = c - 32;
}

int main(int argc, char **argv)
{
	(void)argc;
	ft_striteri(argv[1], &to_uppercase);
	printf("%s", argv[1]);
}*//* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strjoin.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/22 13:28:41 by tmillot           #+#    #+#             */
/*   Updated: 2024/10/27 08:40:01 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

static char	*ft_strcat(char *dest, const char *src)
{
	int	i;
	int	length_dest;

	i = 0;
	length_dest = 0;
	while (dest[length_dest] != '\0')
	{
		length_dest++;
	}
	while (src[i] != '\0')
	{
		dest[length_dest + i] = src[i];
		i++;
	}
	dest[length_dest + i] = '\0';
	return (dest);
}

char	*ft_strjoin(char const *s1, char const *s2)
{
	char	*str;

	str = ft_calloc((ft_strlen(s1) + ft_strlen(s2) + 1), sizeof(char));
	if (!str)
		return (0);
	ft_strcat(str, s1);
	ft_strcat(str, s2);
	return (str);
}

/*int main(int argc, char **argv)
{
	(void)argc;
	char *str = ft_strjoin(argv[1], argv[2]);
	printf("%s", str);
}*//* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strlcat.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/16 18:17:03 by tmillot           #+#    #+#             */
/*   Updated: 2024/10/18 14:30:13 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

size_t	ft_strlcat(char *dest, const char *src, size_t size)
{
	size_t	i;
	size_t	len_dest;
	size_t	len_src;

	i = 0;
	len_src = ft_strlen(src);
	len_dest = ft_strlen(dest);
	if (size <= len_dest)
		return (size + len_src);
	while (i < (size - len_dest - 1) && src[i] != '\0')
	{
		dest[len_dest + i] = src[i];
		i++;
	}
	dest[len_dest + i] = '\0';
	return (len_dest + len_src);
}

/*#include <bsd/string.h>
int main(int argc, char **argv)
{
	(void)argc;
	printf("origin dest : %s\n origin src : %s\n", argv[1], argv[2]);
	printf("%zu\n", ft_strlcat(argv[1], argv[2], atoi(argv[3])));
	printf("after ft_strlcat : %s", argv[1]);
}*//* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strlcpy.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/16 16:40:40 by tmillot           #+#    #+#             */
/*   Updated: 2024/10/16 18:15:29 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

size_t	ft_strlcpy(char *dest, const char *src, size_t size)
{
	size_t	i;
	size_t	len;

	len = 0;
	while (src[len] != '\0')
		len++;
	i = 0;
	if (size > 0)
	{
		while (i < size - 1 && src[i] != '\0')
		{
			dest[i] = src[i];
			i++;
		}
		dest[i] = '\0';
	}
	return (len);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strlen.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/15 13:34:41 by tmillot           #+#    #+#             */
/*   Updated: 2024/10/15 14:47:16 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

size_t	ft_strlen(const char *s)
{
	size_t	len;

	len = 0;
	while (s[len] != '\0')
	{
		len++;
	}
	return (len);
}

/*#include <stdio.h>

int main(int argc, char **argv)
{
	(void)argc;
	printf("%zu", ft_strlen(argv[1]));
}*//* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strmapi.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/24 14:23:26 by tmillot           #+#    #+#             */
/*   Updated: 2024/10/26 18:00:27 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

char	*ft_strmapi(char const *s, char (*f)(unsigned int, char))
{
	char				*str;
	unsigned int		i;

	i = 0;
	str = malloc((ft_strlen(s) + 1) * sizeof(char));
	if (!s || !f)
		return (0);
	if (!str)
		return (0);
	while (s[i] != '\0')
	{
		str[i] = (*f)(i, s[i]);
		i++;
	}
	str[i] = '\0';
	return (str);
}

/*char to_uppercase(unsigned int index, char c) 
{
    (void)index;
    if (c >= 'a' && c <= 'z')
        return (c - 32); 
    return c;
}

int main(int argc, char **argv)
{
	(void)argc;
	char *dest = ft_strmapi(argv[1], to_uppercase);
	printf("%s", dest);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strncmp.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/21 09:52:55 by tmillot           #+#    #+#             */
/*   Updated: 2024/10/26 19:39:48 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_strncmp(const char *s1, const char *s2, size_t n)
{
	size_t	i;

	i = 0;
	if (n == 0)
		return (0);
	while (s1[i] == s2[i] && (i < n - 1) && s1[i] && s2[i])
		i++;
	return ((unsigned char)s1[i] - (unsigned char)s2[i]);
}

/*int main(int argc, char **argv)
{
    (void)argc;
    printf("%d", ft_strncmp(argv[1], argv[2], atoi(argv[3])));
}*//* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strndup.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/20 11:00:28 by tmillot           #+#    #+#             */
/*   Updated: 2025/03/20 11:12:55 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

char	*ft_strndup(const char *s, size_t size)
{
	char		*dup;
	size_t		i;
	size_t		len;

	i = 0;
	len = 0;
	while (len < size && s[len])
		len++;
	dup = malloc((len + 1) * sizeof(char));
	if (!dup)
		return (0);
	if (size == 0)
		return (0);
	while (s[i] && i < len)
	{
		dup[i] = s[i];
		i++;
	}
	dup[i] = '\0';
	return (dup);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strnstr.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/21 11:50:12 by tmillot           #+#    #+#             */
/*   Updated: 2024/10/26 17:49:58 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

char	*ft_strnstr(const char *big, const char *little, size_t len)
{
	size_t	i;
	size_t	j;

	i = 0;
	if (little[0] == '\0')
		return ((char *)big);
	while (big[i] != '\0' && i < len)
	{
		j = 0;
		if (big[i] == little[j])
		{
			while (big[i + j] == little[j] && little[j] && (i + j) < len)
				j++;
			if (little[j] == '\0')
				return ((char *)&big[i]);
		}
		i++;
	}
	return (0);
}

/*#include <bsd/string.h>
int main(int argc, char **argv)
{
	(void)argc;
	printf("%s\n", strnstr(argv[1], argv[2], atoi(argv[3])));
	printf("%s\n", ft_strnstr(argv[1], argv[2], atoi(argv[3])));
}*//* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strrchr.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/21 10:27:27 by tmillot           #+#    #+#             */
/*   Updated: 2024/10/26 15:00:23 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

char	*ft_strrchr(const char *s, int c)
{
	int	len;

	len = ft_strlen(s);
	while (s[len] != (char)c && len >= 0)
		len--;
	if (s[len] == (char)c)
		return ((char *)&s[len]);
	return (NULL);
}

/*int main(int argc, char **argv)
{
	(void)argc;
	printf("%s\n", strrchr(argv[1], argv[2][0]));
	printf("%s", ft_strrchr(argv[1], argv[2][0]));
}*//* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strtrim.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/22 14:57:39 by tmillot           #+#    #+#             */
/*   Updated: 2024/10/22 16:55:03 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

char	*ft_strtrim(char const *s1, char const *set)
{
	int		start;
	int		end;

	start = 0;
	end = ft_strlen(s1);
	while (ft_strchr(set, s1[start]))
		start++;
	while (ft_strchr(set, s1[end]))
		end--;
	return (ft_substr(s1, start, (end - start + 1)));
}

/*int main(int argc, char **argv)
{
	(void)argc;
	char *str;
	str = ft_strtrim(argv[1], argv[2]);
	printf("%s", str);
}*//* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_substr.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/22 10:53:10 by tmillot           #+#    #+#             */
/*   Updated: 2024/10/22 13:27:08 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

char	*ft_substr(char const *s, unsigned int start, size_t len)
{
	size_t	i;
	char	*str;

	i = 0;
	if (!s)
		return (0);
	if (start >= ft_strlen(s))
		return (ft_calloc(1, sizeof(char)));
	if (len > ft_strlen(s) - start)
		len = ft_strlen(s) - start;
	str = ft_calloc(len + 1, sizeof(char));
	if (!str)
		return (0);
	while (i < len)
	{
		str[i] = s[start + i];
		i++;
	}
	return (str);
}

/*int main(void)
{
	char *s = "hello world";
	char *sub = ft_substr(s, 1, 5);
	char *test = ft_calloc(1, sizeof(char));
	printf("%s\n", sub);
	printf("%s", test);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_tolower.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/17 18:17:47 by tmillot           #+#    #+#             */
/*   Updated: 2024/10/17 18:26:56 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_tolower(int c)
{
	if (c >= 'A' && c <= 'Z')
		c += 32;
	return (c);
}

/*int main(int argc, char **argv)
{
	(void)argc;
	printf("%c", ft_tolower(argv[1][0]));
}*//* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_toupper.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/17 17:59:21 by tmillot           #+#    #+#             */
/*   Updated: 2024/10/26 19:11:24 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_toupper(int c)
{
	if (c >= 'a' && c <= 'z')
		c -= 32;
	return (c);
}

/*int main(int argc, char **argv)
{
	(void)argc;
	printf("%c", ft_toupper(argv[1][0]));
}*//* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   toto_t_fill.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/17 10:48:05 by tmillot           #+#    #+#             */
/*   Updated: 2025/05/17 20:48:26 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../core/minishell.h"

void add_back_t_redir(t_redir **redirection, char *file, t_token_type type)
{
	t_redir		*new;
	t_redir		*current;

	new = malloc(sizeof(t_redir));
	if (type == HEREDOC)
		new->file = get_here_doc(file);
	else
		new->file = ft_strdup(file);
	new->type = type;
	new->next = NULL;
	current = *redirection;
	if (*redirection == NULL)
		*redirection = new;
	else
	{
		while (current->next != NULL)
			current = current->next;
		current->next = new;
	}
}

char	**list_to_array_char(t_list *lst)
{
	int		size;
	char	**tab;
	int		i;

	size = ft_lstsize(lst);
	i = 0;
	tab = malloc(sizeof(char *) * (size + 1));
	while (lst != NULL)
	{
		tab[i++] = lst->content;
		lst = lst->next;
	}
	tab[i] = NULL;
	return (tab);
}

void	fill_t_cmd(t_parse_redir *redir, t_cmd *cmd)
{
	int				i;
	t_parse_redir	*current_redir;
	t_list			*args;
	t_cmd			*current_cmd;

	current_redir = redir;
	current_cmd = cmd;
	args = NULL;
	while (current_redir != NULL)
	{
		i = 0;
		while (current_redir->line[i] != NULL)
		{
			if (ft_strncmp(current_redir->line[i], "<", 1) == 0)
			{
				add_back_t_redir(&current_cmd->infile, current_redir->line[i + 1], REDIRECT_IN);
				i += 2;
			}
			else if (ft_strncmp(current_redir->line[i], ">", 1) == 0)
			{
				add_back_t_redir(&current_cmd->outfile, current_redir->line[i + 1], REDIRECT_OUT);
				i += 2;
			}
			else if (ft_strncmp(current_redir->line[i], "<<", 2) == 0)
			{
				add_back_t_redir(&current_cmd->infile, current_redir->line[i + 1], HEREDOC);
				i += 2;
			}
			else if (ft_strncmp(current_redir->line[i], ">>", 2) == 0)
			{
				add_back_t_redir(&current_cmd->outfile, current_redir->line[i + 1], REDIRECT_APPEND);
				i += 2;
			}
			else
			{
				ft_lstadd_back(&args, ft_lstnew(ft_strdup(current_redir->line[i])));
			}
			current_cmd->args = list_to_array_char(args);
			ft_lstclear(&args, free);
			args = NULL;
			i++;
		}
		if (current_redir->next != NULL)
		{
			current_cmd->next = init_cmd();
			current_cmd = current_cmd->next;
		}
		else
			current_cmd->next = NULL;
		current_redir = current_redir->next;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_cd.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/28 18:56:32 by tmillot           #+#    #+#             */
/*   Updated: 2025/05/03 13:58:36 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../core/minishell.h"

static void	update_pwd(t_env **env, char *oldpwd)
{
	t_env	*current;
	char	newpwd[4096];

	current = *env;
	getcwd(newpwd, sizeof(newpwd));
	while (current != NULL)
	{
		if (ft_strcmp(current->key, "PWD") == 0)
			current->value = ft_strdup(newpwd);
		if (ft_strcmp(current->key, "OLDPWD") == 0)
			current->value = ft_strdup(oldpwd);
		current = current->next;
	}
}

static char	*find_home(t_env **env)
{
	t_env	*current;
	char	*find;

	current = *env;
	find = NULL;
	while (current)
	{
		if (ft_strcmp(current->key, "HOME"))
		{
			find = ft_strdup(current->value);
			return (find);
		}
		current = current->next;
	}
	return (find);
}

static void	error_cd(char *message, int type)
{
	ft_putstr_fd("minishell: cd: ", 2);
	ft_putstr_fd(message, 2);
	if (type == 1)
		ft_putstr_fd(": No such file or directory", 2);
	if (type == 2)
		ft_putstr_fd(": Permission denied", 2);
	ft_putstr_fd("\n", 2);
}

int	ft_cd(t_env **env, t_cmd *cmd)
{
	int		nb_args;
	char	currentpwd[4096];
	char	*path;

	nb_args = count_tab_char(cmd->args);
	path = NULL;
	getcwd(currentpwd, sizeof(currentpwd));
	if (nb_args > 2)
		return (error_cd("too many arguments", 0), CODE_FAIL);
	if (nb_args == 2)
		path = ft_strdup(cmd->args[1]);
	if (nb_args == 1)
	{
		path = find_home(env);
		if (path == NULL)
			return (error_cd("HOME not set", 0), CODE_FAIL);
	}
	if (chdir(path) == -1)
	{
		if (access(cmd->args[1], X_OK) == -1)
			return (error_cd(cmd->args[1], 2), CODE_FAIL);
		else
			return (error_cd(cmd->args[1], 1), CODE_FAIL);
	}
	return (update_pwd(env, currentpwd), free(path), CODE_SUCCESS);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_echo.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/19 10:31:12 by lidbaha           #+#    #+#             */
/*   Updated: 2025/04/11 13:39:26 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../core/minishell.h"
#include "../../includes/libft/libft.h"

static int	is_valid_n_option(char *str)
{
	int	i;

	if (!str || str[0] != '-')
		return (0);
	i = 1;
	while (str[i] != '\0')
	{
		if (str[i] != 'n')
			return (0);
		i++;
	}
	if (i > 1)
		return (1);
	return (0);
}

static int	count_n_options(char **args)
{
	int	count;
	int	i;

	count = 0;
	i = 1;
	while (args[i] != NULL && is_valid_n_option(args[i]))
	{
		count++;
		i++;
	}
	return (count);
}

int	ft_echo(t_cmd *cmd)
{
	int	n_options;
	int	i;
	int	first_arg;

	n_options = count_n_options(cmd->args);
	i = 1 + n_options;
	first_arg = 1;
	while (cmd->args[i])
	{
		if (first_arg == 0)
			write(1, " ", 1);
		write(1, cmd->args[i], ft_strlen(cmd->args[i]));
		first_arg = 0;
		i++;
	}
	if (n_options == 0)
		write(1, "\n", 1);
	return (CODE_SUCCESS);
}

/*int main(int ac, char **av)
{
    t_cmd *commande;
    int i;
    commande = malloc(sizeof(t_cmd));
    commande->args = malloc(sizeof(char *) * (ac));
	i = 0;
	while (i < ac)
	{
		commande->args[i] = av[i + 1];
		printf("args[%d] = %s \n", i, commande->args[i]);
		i++;
	}
    commande->args[ac] = NULL;
    ft_echo(commande);
    free(commande->args);
    free(commande);
    return 0;
}*//* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_env.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/20 14:37:05 by tmillot           #+#    #+#             */
/*   Updated: 2025/04/11 13:39:08 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../core/minishell.h"

static void	error_env(char *args)
{
	ft_putstr_fd("env: \'", 2);
	ft_putstr_fd(args, 2);
	ft_putstr_fd("\': No such file or directory\n", 2);
}

int	ft_env(t_env *env, t_cmd *cmd)
{
	t_env	*current;

	current = env;
	if (count_tab_char(cmd->args) > 1)
		return (error_env(cmd->args[1]), 127);
	while (current)
	{
		if (current->value != NULL)
		{
			ft_putstr_fd(current->key, 1);
			ft_putstr_fd("=", 1);
			ft_putstr_fd(current->value, 1);
			ft_putstr_fd("\n", 1);
		}
		current = current->next;
	}
	return (CODE_SUCCESS);
}

/*int main(int ac, char **av, char **env)
{
	t_env *envp;

	envp = cpy_env(env);
	t_cmd *commande;
    int i;
    commande = malloc(sizeof(t_cmd));
    commande->args = malloc(sizeof(char *) * (ac));
	i = 0;
	while (i < ac)
	{
		commande->args[i] = av[i + 1];
		i++;
	}
	commande->args[ac] = NULL;

	ft_env(envp, commande);
}*//* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_exit.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/01 10:52:14 by tmillot           #+#    #+#             */
/*   Updated: 2025/04/30 11:23:07 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../core/minishell.h"

int	ft_check_atoll(const char *str, int *err)
{
	int					neg;
	unsigned long long	res;
	int					i;

	res = 0;
	i = 0;
	neg = 1;
	while ((str[i] >= '\t' && str[i] <= '\r') || str[i] == ' ')
		i++;
	if (str[i] == '-' || str[i] == '+')
	{
		if (str[i++] == '-')
			neg *= -1;
	}
	while (str[i])
	{
		if (ft_isdigit(str[i]))
			res = (res * 10) + (str[i] - '0');
		else
			*err = -1;
		if ((neg == 1 && res > LL_MAX) || (neg == -1 && res > LL_MAX + 1))
			*err = -1;
		i++;
	}
	return ((int)((res * (unsigned long long)neg) % 255));
}

void	exit_code(t_cmd *cmd, int exit_code, int do_exit)
{
	ft_putstr_fd("exit\n", 1);
	if (do_exit == 0)
	{
		if (cmd != NULL)
			free_t_cmd(cmd);
		exit(exit_code);
	}
}

int	ft_exit(t_cmd *cmd, int exit_status)
{
	int	err;
	int	size;

	size = count_tab_char(cmd->args);
	err = 0;
	ft_putstr_fd("exit\n", 1);
	if (size > 2)
	{
		exit_status = ft_check_atoll(cmd->args[1], &err);
		if (err == -1)
		{
			ft_putstr_fd(ERR_NUM_EXIT, 2);
			return (exit_code(cmd, 2, 0), 2);
		}
		else if (err == 0 && size == 2)
			return (exit_code(cmd, exit_status, 0), exit_status);
		else
		{
			ft_putstr_fd(ERR_ARG_EXIT, 2);
			return (1);
		}
	}
	else
		return (exit_code(cmd, 0, 0), 0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_export.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/20 20:18:37 by thomas            #+#    #+#             */
/*   Updated: 2025/05/12 17:48:07 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../core/minishell.h"

static t_env	*sort_t_env(t_env *env)
{
	int		swapped;
	t_env	**ptr;
	t_env	*current;
	t_env	*next_node;

	swapped = 1;
	while (swapped)
	{
		swapped = 0;
		ptr = &env;
		while (*ptr && (*ptr)->next)
		{
			current = *ptr;
			next_node = current->next;
			if (ft_strcmp(current->key, next_node->key) > 0)
			{
				current->next = next_node->next;
				next_node->next = current;
				*ptr = next_node;
				swapped = 1;
			}
			ptr = &(*ptr)->next;
		}
	}
	return (env);
}

int	name_var_valid(char *str)
{
	int	i;

	i = 0;
	if (ft_isalpha(str[i]) == 0 && str[i] != '_')
		return (0);
	i++;
	while (str[i] != '\0')
	{
		if (ft_isalnum(str[i]) == 0 && str[i] != '_')
			return (0);
		i++;
	}
	return (1);
}

static void	add_var_to_env(char *key, char *value, t_env **env)
{
	t_env	*current;
	t_env	*new_node;

	current = *env;
	while (current->next)
	{
		if (ft_strcmp(current->key, key) == 0)
		{
			free(current->value);
			current->value = ft_strdup(value);
			return ;
		}
		current = current->next;
	}
	new_node = malloc(sizeof(t_env));
	if (!new_node)
		return ;
	new_node->key = ft_strdup(key);
	if (value == NULL)
		new_node->value = NULL;
	else
		new_node->value = ft_strdup(value);
	new_node->next = NULL;
	current->next = new_node;
}

static int	add_export(t_env **env, t_cmd *cmd)
{
	int		i;
	char	*before;
	char	*after;

	i = 1;
	while (cmd->args[i])
	{
		before = cmd->args[i];
		after = cmd->args[i];
		if (name_var_valid(before) == 0)
		{
			ft_printf("minishell: export: '%s' :not a valid identifier",
				before);
			return (EXIT_FAILURE);
		}
		else
			add_var_to_env(before, after, env);
		free(after);
		free(before);
		i++;
	}
	return (CODE_SUCCESS);
}

int	ft_export(t_env **env, t_cmd *cmd)
{
	t_env	*cpy;
	int		exit_status;

	cpy = *env;
	exit_status = CODE_SUCCESS;
	if (cmd->args[1] == NULL && ft_strcmp(cmd->args[0], "export") == 0)
	{
		cpy = sort_t_env(cpy);
		while (cpy)
		{
			ft_printf("declare -x %s=\"%s\"\n", cpy->key, cpy->value);
			cpy = cpy->next;
		}
	}
	else
		exit_status = add_export(env, cmd);
	return (exit_status);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_pwd.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/28 19:05:42 by tmillot           #+#    #+#             */
/*   Updated: 2025/05/14 19:17:25 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../core/minishell.h"

int	ft_pwd(void)
{
	char	buffer[4096];

	if (getcwd(buffer, sizeof(buffer)) == NULL)
	{
		perror("getcwd");
		return (CODE_FAIL);
	}
	ft_putstr_fd(buffer, 1);
	ft_putchar_fd('\n', 1);
	return (CODE_SUCCESS);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_unset.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/27 15:13:10 by thomas            #+#    #+#             */
/*   Updated: 2025/04/11 13:48:58 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../core/minishell.h"

static void	rm_node(char *to_rm, t_env **env)
{
	t_env	*current;
	t_env	*prev;

	current = *env;
	prev = NULL;
	while (current != NULL)
	{
		if (ft_strcmp(current->key, to_rm) == 0)
		{
			if (prev != NULL)
				prev->next = current->next;
			else
				*env = current->next;
			free(current->key);
			free(current->value);
			free(current);
			break ;
		}
		prev = current;
		current = current->next;
	}
}

int	ft_unset(t_cmd *cmd, t_env **env)
{
	int		i;

	i = 1;
	while (cmd->args[i] != NULL)
	{
		rm_node(cmd->args[i], env);
		i++;
	}
	return (CODE_SUCCESS);
}

/*int main(int ac, char **av, char **env)
{
	t_env *envp;

	envp = cpy_env(env);
	t_cmd *commande_unset;
    int i;
    commande_unset = malloc(sizeof(t_cmd));
    commande_unset->args = malloc(sizeof(char *) * (ac));
	i = 0;
	while (i < ac)
	{
		commande_unset->args[i] = av[i + 1];
		i++;
	}
	commande_unset->args[ac] = NULL;
	ft_unset(commande_unset, &envp);
	t_cmd *commande_env;
    commande_env = malloc(sizeof(t_cmd));
    commande_env->args = malloc(sizeof(char *) * (2));
	char *truc = "env";
	commande_env->args[0] = truc;
	commande_env->args[1] = NULL;
	ft_env(envp, commande_env);
}*//* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils_built_in.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/01 17:18:04 by tmillot           #+#    #+#             */
/*   Updated: 2025/04/01 17:21:37 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../core/minishell.h"

int	count_tab_char(char **tab)
{
	int	count;

	count = 0;
	while (tab[count] != NULL)
		count++;
	return (count);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   clean.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lidbaha <lidbaha@student.42lehavre.fr>     +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/25 14:38:51 by lidbaha           #+#    #+#             */
/*   Updated: 2025/03/29 06:16:09 by lidbaha          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../core/minishell.h"

void	free_tab(char **tab, int y)
{
	while (y >= 0)
		free(tab[y--]);
	free(tab);
}

void	clean_split(char **split)
{
	int	i;

	if (!split)
		return ;
	i = 0;
	while (split[i])
	{
		free(split[i]);
		i++;
	}
	free(split);
}

void	clean_quotes(t_quotes *quotes)
{
	while (quotes->next != NULL)
	{
		free(quotes->line);
		quotes = quotes->next;
	}
	free(quotes);
}

void	clean_cmd(t_parse *cmd)
{
	clean_split(cmd->space->line);
	clean_split(cmd->pipe->line);
	clean_split(cmd->redir_input->line);
	clean_split(cmd->redir_output->line);
	clean_split(cmd->redir_append->line);
	clean_split(cmd->redir_heredoc->line);
	if (cmd->line)
		free(cmd->line);
	if (cmd->space)
		free(cmd->space);
	if (cmd->pipe)
		free(cmd->pipe);
	if (cmd->redir_input)
		free(cmd->redir_input);
	if (cmd->redir_output)
		free(cmd->redir_output);
	if (cmd->redir_append)
		free(cmd->redir_append);
	if (cmd->redir_heredoc)
		free(cmd->redir_heredoc);
	free(cmd);
}

void	clean_env(void)
{
	clear_history();
	rl_clear_signals();
	rl_cleanup_after_signal();
}

void	clean_pipe(char **pipe)
{
	int	i;

	if (!pipe)
		return ;
	i = 0;
	while (pipe[i])
	{
		if (pipe[i] != NULL)
			free(pipe[i]);
		i++;
	}
	free(pipe);
}

void	clean_redir(t_parse_redir *redir)
{
	t_parse_redir	*temp;

	while (redir != NULL)
	{
		temp = redir;
		redir = redir->next;
		clean_split(temp->line);
		free(temp);
	}
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   cpy_env.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/19 18:44:45 by tmillot           #+#    #+#             */
/*   Updated: 2025/03/31 18:22:01 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../core/minishell.h"

char	*get_before_egal(char *str)
{
	int		i;
	int		len;
	char	*res;

	i = 0;
	while (str[i] && str[i] != '=')
		i++;
	len = i;
	res = ft_strndup(str, (size_t)len);
	return (res);
}

char	*get_after_egal(char *str)
{
	char	*egal;
	char	*res;

	egal = ft_strchr(str, '=');
	if (egal == NULL)
		return (NULL);
	if (*(egal + 1) == '\0')
		return (ft_strdup(""));
	res = ft_strdup(egal + 1);
	return (res);
}

t_env	*cpy_env(char **env)
{
	t_env	*head;
	t_env	*current;
	t_env	*new_node;
	int		i;

	i = 0;
	head = NULL;
	current = NULL;
	new_node = NULL;
	while (env[i] != NULL)
	{
		new_node = malloc(sizeof(t_env));
		if (!new_node)
			return (NULL);
		new_node->key = get_before_egal(env[i]);
		new_node->value = get_after_egal(env[i]);
		new_node->next = NULL;
		if (head == NULL)
			head = new_node;
		else
			current->next = new_node;
		current = new_node;
		i++;
	}
	return (head);
}

/*int main(int ac, char **av, char **env)
{
	t_env *envp;

	envp = cpy_env(env);
	while (envp->next != NULL)
	{
		printf("key : %s\n", envp->key);
		printf("value : %s\n", envp->value);
		envp = envp->next;
	}
}*//* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   error_message_exec.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/12 13:44:12 by tmillot           #+#    #+#             */
/*   Updated: 2025/04/30 11:23:31 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../core/minishell.h"

void	command_not_found(char *cmd)
{
	ft_putstr_fd("Minishell:~$ ", 2);
	ft_putstr_fd(cmd, 2);
	ft_putstr_fd(": Command not found\n", 2);
}

void	no_such_file_or_directory(char *cmd)
{
	ft_putstr_fd("Minishell:~$ ", 2);
	ft_putstr_fd(cmd, 2);
	ft_putstr_fd(": No such file or directory\n", 2);
}

void	permission_denied(char *file)
{
	ft_putstr_fd("Minishell:~$ ", 2);
	ft_putstr_fd(file, 2);
	ft_putstr_fd(": Permission denied\n", 2);
}

void	error_message(char *str)
{
	ft_putstr_fd("Minishell:~$ ", 2);
	perror(str);
}

void	is_a_directory(char *str)
{
	ft_putstr_fd("Minishell:~$ ", 2);
	ft_putstr_fd(str, 2);
	ft_putstr_fd(": Is a directory\n", 2);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   executing.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/04 22:16:30 by thomas            #+#    #+#             */
/*   Updated: 2025/05/16 17:37:06 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../core/minishell.h"

int	is_built_in(char *str)
{
	if (ft_strcmp(str, "echo") == 0)
		return (SUCCESS);
	else if (ft_strcmp(str, "cd") == 0)
		return (SUCCESS);
	else if (ft_strcmp(str, "env") == 0)
		return (SUCCESS);
	else if (ft_strcmp(str, "exit") == 0)
		return (SUCCESS);
	else if (ft_strcmp(str, "export") == 0)
		return (SUCCESS);
	else if (ft_strcmp(str, "pwd") == 0)
		return (SUCCESS);
	else if (ft_strcmp(str, "unset") == 0)
		return (SUCCESS);
	else
		return (FAIL);
}

static void	find_built_in(t_cmd *cmd)
{
	t_cmd	*current;

	current = cmd;
	while (current != NULL)
	{
		if (is_built_in(current->args[0]) == SUCCESS)
			current->builtin = true;
		else
			current->builtin = false;
		current = current->next;
	}
}

int	wait_children(int status)
{
	int		cur_status;
	int		final_status;
	pid_t	prev_pid;
	pid_t	cur_pid;

	final_status = status;
	prev_pid = waitpid(-1, &cur_status, 0);
	while (prev_pid > 0)
	{
		cur_pid = waitpid(-1, &cur_status, 0);
		if (prev_pid < cur_pid)
			final_status = cur_status;
		prev_pid = cur_pid;
	}
	if (final_status == 131)
		ft_putstr_fd("quit (core dumped)\n", 2);
	return (final_status % 255);
}

int	ft_exec(t_cmd *cmd, t_env *env, int last_status)
{
	int		pipe_fd[2];
	int		prev_fd;

	find_built_in(cmd);
	expand_and_trim_cmd(cmd, env, last_status);
	if (cmd->next == NULL && is_special_built_in(cmd->args[0]) == SUCCESS)
		return (executing_special_built_in(cmd, env));
	last_status = EXIT_SUCCESS;
	prev_fd = STDIN_FILENO;
	while (cmd)
	{
		if (pipe(pipe_fd) == -1)
			return (perror("pipe error"), EXIT_FAILURE);
		last_status = ft_process(cmd, env, pipe_fd, prev_fd);
		if (prev_fd != 0)
			close(prev_fd);
		if (cmd->next != NULL)
			prev_fd = pipe_fd[0];
		else
			close(pipe_fd[0]);
		close(pipe_fd[0]);
		cmd = cmd->next;
	}
	return (wait_children(last_status));
}

/* attention redirection meme quand il n'y a pas de pipe car special bulting ne gere pas les redirection 
gerer les signaux, fonctions qui ecoutent les signaux dans les processus enfants dans exec child
rehinitialiser les redirection dans la sortie standard sinon ca ecrit dans le fichier out ou in *//* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exit_free_exec.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/14 17:00:39 by tmillot           #+#    #+#             */
/*   Updated: 2025/05/16 16:51:51 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../core/minishell.h"

void	free_tab_char(char **tab)
{
	int	i;

	i = 0;
	while (tab[i] != NULL)
	{
		free(tab[i]);
		i++;
	}
	free(tab);
}

void	free_t_redir(t_redir *list)
{
	t_redir		*temp;

	while (list != NULL)
	{
		if (list->type == HEREDOC)
		{
			if (unlink(list->file) == -1)
				perror("unlink error");
		}
		else
		{
			if (list->file != NULL)
				free(list->file);
		}
		temp = list;
		list = list->next;
		free(temp);
	}
}

void	free_t_cmd(t_cmd *cmd)
{
	while (cmd != NULL)
	{
		free_tab_char(cmd->args);
		if (cmd->infile != NULL)
			free_t_redir(cmd->infile);
		if (cmd->outfile != NULL)
			free_t_redir(cmd->outfile);
		cmd = cmd->next;
		free(cmd);
	}
}

int	ft_exit_exec(int exit_code, t_cmd *cmd, char **envp, char *path_cmd)
{
	free(path_cmd);
	free_t_cmd(cmd);
	free_tab_char(envp);
	exit(exit_code);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   expand_trim_quotes.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/10 12:15:48 by tmillot           #+#    #+#             */
/*   Updated: 2025/05/12 14:07:03 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../core/minishell.h"

void	expand_and_trim_redir(t_redir *redirection, t_env *env, int last_status)
{
	t_redir		*current;
	int			quote;
	int			i;

	current = redirection;
	quote = NO_QUOTE;
	while (current != NULL)
	{
		i = 0;
		while (current->file[i] != '\0')
		{
			check_expand_quote(&quote, current->file[i]);
			if (current->file[i] == '$' && quote != S_QUOTE)
				expand_arg(&current->file, env, last_status, &i);
			i++;
		}
		find_and_trim_quote(&current->file);
		current = current->next;
	}
}

void	expand_and_trim_cmd(t_cmd *cmd, t_env *env, int last_status)
{
	t_cmd	*current;

	current = cmd;
	handling_dollars(cmd, env, last_status);
	trim_quotes(cmd);
	while (current != NULL)
	{
		if (current->infile != NULL)
			expand_and_trim_redir(current->infile, env, last_status);
		if (current->outfile != NULL)
			expand_and_trim_redir(current->outfile, env, last_status);
		current = current->next;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   find_command.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/12 18:55:42 by tmillot           #+#    #+#             */
/*   Updated: 2025/04/30 11:23:43 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../core/minishell.h"

static char	*path_of_env(t_env *env)
{
	t_env	*current;
	char	*path;

	current = env;
	path = NULL;
	while (current != NULL)
	{
		if (ft_strcmp(current->key, "PATH") == 0)
		{
			path = ft_strdup(current->value);
			return (path);
		}
		current = current->next;
	}
	return (path);
}

char	*find_cmd_path(t_env *env, t_cmd *cmd)
{
	int		i;
	char	*path_env;
	char	*res;
	char	*cmd_slash;
	char	**possible_path;

	i = -1;
	res = NULL;
	path_env = path_of_env(env);
	cmd_slash = ft_strjoin("/", cmd->args[0]);
	if (access(cmd->args[0], F_OK | X_OK) == 0)
		return (free(path_env), free(cmd_slash), ft_strdup(cmd->args[0]));
	if (path_env == NULL)
		return (free(path_env), free(cmd_slash),
			command_not_found(cmd->args[0]), NULL);
	possible_path = ft_split(path_env, ':');
	while (possible_path[++i] != NULL)
	{
		res = ft_strjoin(possible_path[i], cmd_slash);
		if (access(res, F_OK | X_OK) == 0)
			return (free(cmd_slash), free(path_env),
				clean_split(possible_path), res);
	}
	command_not_found(cmd->args[0]);
	return (free(cmd_slash), free(path_env), clean_split(possible_path), NULL);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   handle_env_exec.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/13 12:10:09 by tmillot           #+#    #+#             */
/*   Updated: 2025/04/30 11:23:47 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../core/minishell.h"

static int	size_struct_env(t_env *env)
{
	int		count;
	t_env	*current;

	current = env;
	count = 0;
	while (current != NULL)
	{
		count++;
		current = current->next;
	}
	return (count);
}

static char	*join_key_and_value(char *key, char *value)
{
	char	*res;
	int		i;
	int		j;

	res = malloc((ft_strlen(key) + ft_strlen(value) + 2) * sizeof(char));
	i = 0;
	j = 0;
	while (key[i] != '\0')
	{
		res[i] = key[i];
		i++;
	}
	res[i++] = '=';
	if (value != NULL)
		while (value[j] != '\0')
			res[i++] = value[j++];
	res[i] = '\0';
	return (res);
}

char	**env_tab_char(t_env *env)
{
	int		size;
	char	**tab_char;
	int		i;
	t_env	*current;

	size = size_struct_env(env);
	tab_char = malloc((size + 1) * sizeof(char *));
	i = 0;
	current = env;
	while (current != NULL)
	{
		tab_char[i] = join_key_and_value(current->key, current->value);
		current = current->next;
		i++;
	}
	tab_char[i] = NULL;
	return (tab_char);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   handling_dollars.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/05 15:25:30 by tmillot           #+#    #+#             */
/*   Updated: 2025/05/10 13:19:29 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../core/minishell.h"

int	check_expand_quote(int *quote, char c)
{
	if (c == '\'' && *quote != D_QUOTE)
		return (*quote = S_QUOTE, 1);
	else if (c == '\"' && *quote != S_QUOTE)
		return (*quote = D_QUOTE, 1);
	return (0);
}

static int	sep_var_name(char c)
{
	if (c == ' ' || c == '.' || c == '+' || c == '-' || c == '^' || c == ','
		|| c == '*' || c == '/' || c == '%' || c == '=' || c == '\"'
		|| c == '\0')
		return (0);
	return (1);
}

static char	*get_value_env(char *arg, t_env *env, int *index)
{
	char	*value;
	char	*name;
	int		start;
	t_env	*current;

	start = *index + 1;
	name = NULL;
	current = env;
	value = ft_strdup("");
	if (ft_isdigit(arg[start]) == 1)
		return ((*index) += 2, value);
	while (sep_var_name(arg[*index]) == 1 && arg[*index] != '\0')
		*index += 1;
	name = ft_substr(arg, start, (*index - start));
	while (current != NULL)
	{
		if (ft_strcmp(name, current->key) == 0)
		{
			free(value);
			value = ft_strdup(current->value);
			break ;
		}
		current = current->next;
	}
	return (free(name), value);
}

void	expand_arg(char **arg, t_env *env, int last_status, int *index)
{
	char	*before_dollar;
	char	*str_to_expand;
	char	*end_str;
	char	*first_join;

	before_dollar = NULL;
	str_to_expand = ft_strdup("");
	end_str = NULL;
	before_dollar = ft_substr((*arg), 0, *index);
	if ((*arg)[*index + 1] == '?')
	{
		str_to_expand = ft_itoa(last_status);
		*index += 2;
	}
	else if (sep_var_name((*arg)[*index + 1]) == 1)
		str_to_expand = get_value_env((*arg), env, index);
	end_str = ft_substr((*arg), *index, (ft_strlen((*arg)) - *index));
	first_join = ft_strjoin(before_dollar, str_to_expand);
	free((*arg));
	(*arg) = ft_strjoin(first_join, end_str);
	free(before_dollar);
	free(str_to_expand);
	free(end_str);
	free(first_join);
}

void	handling_dollars(t_cmd *cmd, t_env *env, int last_status)
{
	t_cmd		*current;
	int			quote;
	int			i;
	int			j;

	current = cmd;
	while (current != NULL)
	{
		i = 0;
		while (current->args[i] != NULL)
		{
			j = 0;
			quote = NO_QUOTE;
			while (current->args[i][j] != '\0')
			{
				check_expand_quote(&quote, current->args[i][j]);
				if (current->args[i][j] == '$' && quote != S_QUOTE)
					expand_arg(&current->args[i], env, last_status, &j);
				j++;
			}
			i++;
		}
		current = current->next;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   open_redirection.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/13 16:25:36 by tmillot           #+#    #+#             */
/*   Updated: 2025/05/16 17:38:07 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../core/minishell.h"

static int	open_infile(char *file)
{
	int	fd;

	fd = open(file, O_RDONLY);
	if (fd == -1)
	{
		if (access(file, R_OK) == -1)
			permission_denied(file);
		else if (access(file, F_OK) == -1)
			no_such_file_or_directory(file);
		else
			error_message(file);
	}
	return (fd);
}

int	last_infile(t_cmd *cmd)
{
	int			fd;
	int			prev;
	t_redir		*infile;

	infile = cmd->infile;
	prev = -1;
	while (infile)
	{
		fd = open_infile(infile->file);
		if (prev != -1)
			close(prev);
		if (fd == -1)
			break ;
		prev = fd;
		infile = infile->next;
	}
	return (fd);
}

static int	open_outfile(char *file, t_token_type mode)
{
	int	fd;

	if (mode == REDIRECT_APPEND)
		fd = open(file, O_WRONLY | O_CREAT | O_APPEND, 0644);
	else
		fd = open(file, O_WRONLY | O_CREAT | O_TRUNC, 0644);
	if (fd == -1)
	{
		if (access(file, W_OK) == -1)
			permission_denied(file);
		else
			error_message(file);
	}
	return (fd);
}

int	last_outfile(t_cmd *cmd)
{
	int			fd;
	int			prev;
	t_redir		*outfile;

	outfile = cmd->outfile;
	prev = -1;
	while (outfile)
	{
		fd = open_outfile(outfile->file, outfile->type);
		if (prev != -1)
			close(prev);
		if (fd == -1)
			break ;
		prev = fd;
		outfile = outfile->next;
	}
	return (fd);
}

/* attention le break ne suffit pas ici *//* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   processus.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/12 18:58:31 by tmillot           #+#    #+#             */
/*   Updated: 2025/04/30 13:50:43 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../core/minishell.h"

static int	run_executable(t_cmd *cmd, char **envp)
{
	struct stat	data;

	if (access(cmd->args[0], F_OK) == -1)
		return (command_not_found(cmd->args[0]), 127);
	if (access(cmd->args[0], X_OK) == -1)
		return (permission_denied(cmd->args[0]), 126);
	if (stat(cmd->args[0], &data) != 0)
		return (perror("stat"), CODE_FAIL);
	if (S_ISREG(data.st_mode) == 0)
		return (is_a_directory(cmd->args[0]), 126);
	if (execve(*cmd->args, cmd->args, envp) == -1)
		perror("execve");
	return (CODE_FAIL);
}

int	exec_builtin(t_cmd *cmd, t_env *env)
{
	if (ft_strcmp(cmd->args[0], "echo") == 0)
		return (ft_echo(cmd));
	if (ft_strcmp(cmd->args[0], "pwd") == 0)
		return (ft_pwd());
	if (ft_strcmp(cmd->args[0], "env") == 0)
		return (ft_env(env, cmd));
	return (-1);
}

int	child_process(t_env *env, t_cmd *cmd, char **envp, char *path_cmd)
{
	struct stat	data;

	if (*cmd->args[0] == '.' || *cmd->args[0] == '/')
		ft_exit_exec(run_executable(cmd, envp), cmd, envp, path_cmd);
	if (is_special_built_in(cmd->args[0]) == SUCCESS)
		ft_exit_exec(executing_special_built_in(cmd, env),
			cmd, envp, path_cmd);
	if (cmd->builtin == true && env != NULL)
		ft_exit_exec(exec_builtin(cmd, env), cmd, envp, path_cmd);
	if (path_cmd == NULL)
		ft_exit_exec(127, cmd, envp, path_cmd);
	if (stat(path_cmd, &data) != 0)
		return (perror("stat"), CODE_FAIL);
	if (S_ISREG(data.st_mode) == 0)
		return (is_a_directory(cmd->args[0]), 126);
	if (execve(path_cmd, cmd->args, envp) == -1)
		perror("execve");
	return (ft_exit_exec(CODE_FAIL, cmd, envp, path_cmd));
}

int	ft_process(t_cmd *cmd, t_env *env, int *pipe_fd, int prev_fd)
{
	char	*path_cmd;
	int		redir;
	char	**envp;
	pid_t	pid;

	if (env == NULL && cmd->args[0] != NULL && is_built_in(*cmd->args) == FAIL)
		return (no_such_file_or_directory(cmd->args[0]), 127);
	path_cmd = NULL;
	if (cmd->args[0] != NULL && *cmd->args[0] != '.'
		&& *cmd->args[0] != '/' && is_built_in(*cmd->args) == FAIL)
	{
		path_cmd = find_cmd_path(env, cmd);
		envp = env_tab_char(env);
	}
	pid = fork();
	if (pid == -1)
		return (perror("fork"), CODE_FAIL);
	if (pid != 0)
		return (CODE_SUCCESS);
	redir = redirect_management(cmd, pipe_fd, prev_fd);
	if (redir == CODE_SUCCESS && cmd->args[0] != NULL)
		child_process(env, cmd, envp, path_cmd);
	ft_exit_exec(redir, cmd, envp, path_cmd);
	return (EXIT_SUCCESS);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   redirect_management.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/13 14:00:58 by tmillot           #+#    #+#             */
/*   Updated: 2025/05/16 17:37:21 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../core/minishell.h"

static int	management_infile(t_cmd *cmd, int prev_fd)
{
	int	in_fd;

	if (cmd->infile == NULL && prev_fd == 0)
		return (CODE_SUCCESS);
	if (cmd->infile == NULL && prev_fd != 0)
		return (dup2(prev_fd, 0), close(prev_fd), CODE_SUCCESS);
	if (prev_fd != 0)
		close(prev_fd);
	in_fd = last_infile(cmd);
	if (in_fd == -1)
		return (CODE_FAIL);
	return (dup2(in_fd, 0), close(in_fd), CODE_SUCCESS);
}

static int	management_outfile(t_cmd *cmd, int *pipe_fd)
{
	int	out_fd;

	if (cmd->outfile == NULL && cmd->next == NULL)
		return (CODE_SUCCESS);
	if (cmd->outfile == NULL)
		return (dup2(pipe_fd[1], 1), CODE_SUCCESS);
	out_fd = last_outfile(cmd);
	if (out_fd == -1)
		return (dup2(pipe_fd[1], 1), CODE_FAIL);
	return (dup2(out_fd, 1), close(out_fd), CODE_FAIL);
}

int	redirect_management(t_cmd *cmd, int *pipe_fd, int prev_fd)
{
	if (management_infile(cmd, prev_fd) == CODE_FAIL)
		return (close(pipe_fd[0]), close(pipe_fd[1]), CODE_FAIL);
	if (management_outfile(cmd, pipe_fd) == CODE_FAIL)
		return (close(pipe_fd[0]), close(pipe_fd[1]), CODE_FAIL);
	return (close(pipe_fd[0]), close(pipe_fd[1]), CODE_SUCCESS);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   speciale_built_in.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/19 18:06:03 by tmillot           #+#    #+#             */
/*   Updated: 2025/04/30 11:24:03 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../core/minishell.h"

int	is_special_built_in(char *cmd)
{
	if (ft_strcmp(cmd, "cd") == 0)
		return (SUCCESS);
	else if (ft_strcmp(cmd, "export") == 0)
		return (SUCCESS);
	else if (ft_strcmp(cmd, "unset") == 0)
		return (SUCCESS);
	else if (ft_strcmp(cmd, "exit") == 0)
		return (SUCCESS);
	else
		return (FAIL);
}

int	executing_special_built_in(t_cmd *cmd, t_env *env)
{
	if (ft_strcmp(cmd->args[0], "cd") == 0)
		return (ft_cd(&env, cmd));
	else if (ft_strcmp(cmd->args[0], "export") == 0)
		return (ft_export(&env, cmd));
	else if (ft_strcmp(cmd->args[0], "unset") == 0)
		return (ft_unset(cmd, &env));
	else if (ft_strcmp(cmd->args[0], "exit") == 0)
		return (ft_exit(cmd, 0));
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   trim_quote.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/10 07:06:39 by tmillot           #+#    #+#             */
/*   Updated: 2025/05/12 17:53:51 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../core/minishell.h"

int	check_status_quote(int *quote, char c)
{
	if (c == '\'' && *quote == NO_QUOTE)
		return (*quote = S_QUOTE, 1);
	else if (c == '\'' && *quote == S_QUOTE)
		return (*quote = NO_QUOTE, 1);
	else if (c == '\"' && *quote == NO_QUOTE)
		return (*quote = D_QUOTE, 1);
	else if (c == '\"' && *quote == D_QUOTE)
		return (*quote = NO_QUOTE, 1);
	return (0);
}

void	change_str(char *arg, int len)
{
	int	i;

	i = 0;
	while (arg[i + len] != '\0')
	{
		arg[i] = arg[i + len];
		i++;
	}
	arg[i] = '\0';
}

void	find_and_trim_quote(char **arg)
{
	int	index;
	int	quote;

	index = 0;
	quote = NO_QUOTE;
	while ((*arg)[index] != '\0')
	{
		check_status_quote(&quote, (*arg)[index]);
		if (((*arg)[index] == '\"' && quote != S_QUOTE))
			change_str((*arg) + index--, 1);
		else if ((*arg)[index] == '\'' && quote != D_QUOTE)
			change_str((*arg) + index--, 1);
		index++;
	}
}

void	trim_quotes(t_cmd *cmd)
{
	t_cmd	*current;
	int		i;

	current = cmd;
	while (current != NULL)
	{
		i = 0;
		while (current->args[i] != NULL)
		{
			find_and_trim_quote(&current->args[i]);
			i++;
		}
		current = current->next;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   fill_cmd.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/13 22:17:23 by lidbaha           #+#    #+#             */
/*   Updated: 2025/05/17 12:04:05 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../core/minishell.h"

t_cmd	*init_cmd(void)
{
	t_cmd	*cmd;

	cmd = malloc(sizeof(t_cmd));
	if (!cmd)
		return (NULL);
	cmd->args = NULL;
	cmd->next = NULL;
	cmd->infile = NULL;
	cmd->outfile = NULL;

	return (cmd);
}

// void	fill_t_cmd(t_parse_redir *redir, t_cmd *cmd)
// {
// 	t_parse_redir	*current;
// 	t_cmd			*current_cmd;

// 	current = redir;
// 	current_cmd = cmd;
// 	//TODO: fill cmd
// }/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   here_doc.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/15 21:46:35 by tmillot           #+#    #+#             */
/*   Updated: 2025/05/16 16:20:05 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../core/minishell.h"

void	made_new_file(int *fd, char **name)
{
	static int	nb_file = 0;

	*name = ft_strjoin("/tmp/here_doc_", ft_itoa(nb_file));
	*fd = open(*name, O_RDWR | O_CREAT | O_TRUNC, 0644);
	nb_file++;
}

void	fill_here_doc_file(int fd, char *delimitor)
{
	char	*str;

	while (1)
	{
		str = readline("> ");
		if (str == NULL)
		{
			ft_printf("bash: warning: here-document delimited"
				" by end-of-file (wanted `%s')\n", delimitor);
			break ;
		}
		if (ft_strcmp(str, delimitor) == 0)
		{
			free(str);
			break ;
		}
		ft_putstr_fd(str, fd);
		ft_putchar_fd('\n', fd);
		free(str);
	}
}

char	*get_here_doc(char *str)
{
	char	*file_name;
	char	*delimitor;
	int		here_doc_fd;

	delimitor = ft_strdup(str);
	file_name = NULL;
	made_new_file(&here_doc_fd, &file_name);
	if (here_doc_fd == -1)
		return (ft_printf("error to create a tmp file\n"), NULL);
	fill_here_doc_file(here_doc_fd, delimitor);
	close(here_doc_fd);
	return (file_name);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse_redir.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lidbaha <lidbaha@student.42lehavre.fr>     +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/04 12:25:23 by lidbaha           #+#    #+#             */
/*   Updated: 2025/05/04 12:25:33 by lidbaha          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../core/minishell.h"

t_parse_redir	*add_list(char **line)
{
	t_parse_redir	*dest;

	dest = malloc(sizeof(t_parse_redir));
	if (!dest)
		return (NULL);
	dest->line = ft_strdup_split(line);
	dest->next = NULL;
	return (dest);
}

void	tab_to_redir_char(t_parse_redir *redir, char **pipe, char sep)
{
	int				i;
	char			**temp;
	t_parse_redir	*current;

	i = 0;
	current = redir;
	while (pipe[i] != NULL)
	{
		temp = ft_divide_char(pipe[i], sep);
		if (current->line == NULL)
		{
			current->line = ft_strdup_split(temp);
			current->next = NULL;
		}
		else
		{
			while (current->next != NULL)
				current = current->next;
			current->next = add_list(temp);
		}
		clean_split(temp);
		i++;
	}
}

void	tab_to_redir_str(t_parse_redir *redir, char **pipe, char *sep)
{
	int				i;
	char			**temp;
	t_parse_redir	*current;

	i = 0;
	current = redir;
	while (pipe[i] != NULL)
	{
		temp = ft_divide_str(pipe[i], sep);
		if (current->line == NULL)
		{
			current->line = ft_strdup_split(temp);
			current->next = NULL;
		}
		else
		{
			while (current->next != NULL)
				current = current->next;
			current->next = add_list(temp);
		}
		clean_split(temp);
		i++;
	}
}

int	len_list(t_parse_redir *redir)
{
	int				i;
	int				len;
	t_parse_redir	*current;

	len = 0;
	current = redir;
	while (current != NULL)
	{
		i = 0;
		while (current->line[i] != NULL)
			i++;
		len += i;
		current = current->next;
	}
	return (len);
}

char	**tab_join(t_parse_redir *redir)
{
	int				i;
	int				index;
	char			**tab;
	t_parse_redir	*current;

	current = redir;
	index = 0;
	tab = malloc(sizeof(char *) * (len_list(redir) + 1));
	while (current != NULL)
	{
		i = 0;
		while (current->line[i] != NULL)
		{
			tab[index] = ft_strdup(current->line[i]);
			i++;
			index++;
		}
		current = current->next;
	}
	return (tab);
}

void	parse_lst_redir_char(t_parse_redir *redir)
{
	char			**line_temp;
	t_parse_redir	*temp;
	t_parse_redir	*current;

	current = redir;
	while (current != NULL)
	{
		temp = init_redir();
		tab_to_redir_char(temp, current->line, '<');
		line_temp = tab_join(temp);
		clean_split(current->line);
		current->line = ft_strdup_split(line_temp);
		clean_split(line_temp);
		clean_redir(temp);
		current = current->next;
	}
}

void	parse_lst_redir_str(t_parse_redir *redir, char *sep)
{
	char			**line_temp;
	t_parse_redir	*temp;
	t_parse_redir	*current;

	current = redir;
	while (current != NULL)
	{
		temp = init_redir();
		tab_to_redir_str(temp, current->line, sep);
		line_temp = tab_join(temp);
		clean_split(current->line);
		current->line = ft_strdup_split(line_temp);
		clean_split(line_temp);
		clean_redir(temp);
		current = current->next;
	}
}

void	parse_redir(t_parse_redir *redir, char **pipe)
{
	tab_to_redir_char(redir, pipe, '>');
	parse_lst_redir_char(redir);
	parse_lst_redir_str(redir, ">>");
	parse_lst_redir_str(redir, "<<");
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse_type.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lidbaha <lidbaha@student.42lehavre.fr>     +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/25 14:42:43 by lidbaha           #+#    #+#             */
/*   Updated: 2025/03/26 18:27:48 by lidbaha          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../core/minishell.h"

void	parse_pipe(t_parse *cmd, char *line)
{
	char			**tmp;
	t_parse_pipe	*pipe;

	pipe = malloc(sizeof(t_parse_pipe));
	tmp = ft_minishell_split_char(line, '|');
	pipe->line = ft_strdup_split(tmp);
	cmd->pipe = pipe;
	clean_split(tmp);
}

void	parse_redir_input(t_parse *cmd, char *line)
{
	char				**tmp;
	t_parse_redir_input	*redir_input;

	redir_input = malloc(sizeof(t_parse_redir_input));
	tmp = ft_minishell_split_char(line, '<');
	redir_input->line = ft_strdup_split(tmp);
	cmd->redir_input = redir_input;
	clean_split(tmp);
}

void	parse_redir_output(t_parse *cmd, char *line)
{
	char					**tmp;
	t_parse_redir_output	*redir_output;

	redir_output = malloc(sizeof(t_parse_redir_output));
	tmp = ft_minishell_split_char(line, '>');
	redir_output->line = ft_strdup_split(tmp);
	cmd->redir_output = redir_output;
	clean_split(tmp);
}

void	parse_redir_append(t_parse *cmd, char *line)
{
	char					**tmp;
	t_parse_redir_append	*redir_append;

	redir_append = malloc(sizeof(t_parse_redir_append));
	tmp = ft_minishell_split_str(line, ">>");
	redir_append->line = ft_strdup_split(tmp);
	cmd->redir_append = redir_append;
	clean_split(tmp);
}

void	parse_redir_heredoc(t_parse *cmd, char *line)
{
	char					**tmp;
	t_parse_redir_heredoc	*redir_heredoc;

	redir_heredoc = malloc(sizeof(t_parse_redir_heredoc));
	tmp = ft_minishell_split_str(line, "<<");
	redir_heredoc->line = ft_strdup_split(tmp);
	cmd->redir_heredoc = redir_heredoc;
	clean_split(tmp);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parsing.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lidbaha <lidbaha@student.42lehavre.fr>     +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/19 10:10:52 by lidbaha           #+#    #+#             */
/*   Updated: 2025/03/25 16:12:22 by lidbaha          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../core/minishell.h"

void	parse_space(t_parse *cmd, char *line)
{
	char			**tmp;
	t_parse_space	*space;

	space = malloc(sizeof(t_parse_space));
	tmp = ft_split(line, ' ');
	space->line = ft_strdup_split(tmp);
	cmd->space = space;
	clean_split(tmp);
}

void	check_line(t_parse *cmd)
{
	if (cmd->space->line[0] == NULL)
		return ;
	if (ft_strcmp(cmd->space->line[0], "exit") == 0
		&& cmd->space->line[1] == NULL)
	{
		clean_cmd(cmd);
		clean_env();
		exit(0);
	}
}

t_quotes	*init_quotes(void)
{
	t_quotes	*tmp;

	tmp = malloc(sizeof(t_quotes));
	tmp->line = NULL;
	tmp->index = 0;
	tmp->next = NULL;
	return (tmp);
}

void	parse(char *line)
{
	t_parse			*cmd;
	t_quotes		*quotes;

	if (line[0] != '\0')
	{
		cmd = malloc(sizeof(t_parse));
		quotes = init_quotes();
		cmd->line = ft_strdup(line);
		line = remove_quotes(line, quotes);
		parse_space(cmd, line);
		parse_pipe(cmd, line);
		parse_redir_input(cmd, line);
		parse_redir_output(cmd, line);
		parse_redir_append(cmd, line);
		parse_redir_heredoc(cmd, line);
		//replace_quotes(cmd, quotes);
		check_line(cmd);
		clean_quotes(quotes);
		clean_cmd(cmd);
	}
	else
		free(line);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parsing_v2.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/12 17:55:23 by lidbaha           #+#    #+#             */
/*   Updated: 2025/05/17 20:49:23 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../core/minishell.h"

int	check_quote_closed(char *line, int index, char quote)
{
	while (line[index] != '\0')
	{
		if (line[index] == quote)
			break ;
		index++;
	}
	if (line[index] == quote)
		return (index);
	return (-1);
}

char	*skip_quotes(char *line, char quote)
{
	line++;
	while (*line != quote)
		line++;
	line++;
	return (line);
}

int	check_if_valid(char *line, char sep)
{
	int	i;
	int	valid;

	i = 0;
	valid = 1;
	if (line[0] == sep && line[1] != sep)
		return (1);
	while (line[i] != '\0')
	{
		if (line[i] == sep && line[i + 1] != sep && line[i - 1] != sep)
		{
			if (valid == 1)
				return (1);
			valid = 1;
			if (line[i + 1] == '\0')
				return (1);
			i++;
		}
		if (valid == 1)
			if (line[i] != ' ' && line[i] != '\t' && line[i] != '\n'
				&& line[i] != '\r' && line[i] != 32)
				valid = 0;
		i++;
	}
	return (valid);
}

t_parse_redir	*init_redir(void)
{
	t_parse_redir	*redir;

	redir = malloc(sizeof(t_parse_redir));
	if (!redir)
		return (NULL);
	redir->line = NULL;
	redir->next = NULL;
	return (redir);
}

int	parse_v2(char *line, t_env *env, int last_status)
{
	int				i;
	char			**pipe;
	t_parse_redir	*redir;
	t_cmd			*cmd;

	i = 0;
	if (line[0] == '\0')
		return (-1);
	while (line[i] != '\0')
	{
		if (line[i] == '\'' || line[i] == '\"')
		{
			if (check_quote_closed(line, i + 1, line[i]) != -1)
				i = check_quote_closed(line, i + 1, line[i]) + 1;
			else
				exit(1); //TODO: return error (unclosed quote)
		}
		i++;
	}
	if (check_if_valid(line, '|') == 1)
		return (-1); //TODO: return error (missing pipe argument)
	pipe = ft_divide_char(line, '|');
	redir = init_redir();
	parse_redir(redir, pipe);
	cmd = init_cmd();
	fill_t_cmd(redir, cmd);
	clean_pipe(pipe);
	clean_redir(redir);
	last_status = ft_exec(cmd, env, last_status);
	return (last_status);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_divide_char.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lidbaha <lidbaha@student.42lehavre.fr>     +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/12 17:55:08 by lidbaha           #+#    #+#             */
/*   Updated: 2025/04/12 17:55:09 by lidbaha          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../core/minishell.h"

int	divide_size(char *line, char sep)
{
	int	i;
	int	result;

	i = 0;
	result = 0;
	while (line[i] != '\0')
	{
		if (line[i] == '\"' || line[i] == '\'')
			i = check_quote_closed(line, i + 1, line[i]) + 1;
		if (line[i] == sep && line[i + 1] != sep)
			result++;
		i++;
	}
	return (result);
}

char	*add_sep(char sep)
{
	char	*result;

	result = malloc(sizeof(char) * 2);
	if (!result)
		return (NULL);
	result[0] = sep;
	result[1] = '\0';
	return (result);
}

char	*add_chunk(char *line, int start, int end)
{
	char	*chunk;
	int		i;

	i = 0;
	chunk = malloc(sizeof(char) * (end - start + 2));
	if (!chunk)
		return (NULL);
	while (start <= end)
	{
		chunk[i] = line[start];
		i++;
		start++;
	}
	chunk[i] = '\0';
	return (chunk);
}

void	divide(char *line, char **result, char sep)
{
	int	i;
	int	start;
	int	index;

	i = 0;
	start = 0;
	index = 0;
	while (line[i] != '\0')
	{
		if (line[i] == '\"' || line[i] == '\'')
			i = check_quote_closed(line, i + 1, line[i]) + 1;
		if (line[i] == sep && line[i + 1] != sep && line[i - 1] != sep)

		{
			result[index] = add_chunk(line, start, i - 1);
			result[index + 1] = add_sep(sep);
			start = i + 1;
			index += 2;
		}
		i++;
	}
	if (start < i)
	{
		result[index] = add_chunk(line, start, i - 1);
		index++;
	}
	result[index] = NULL;
}

char	**ft_divide_char(char *line, char sep)
{
	char	**result;

	result = malloc(sizeof(char *) * (divide_size(line, sep) * 2 + 2));
	divide(line, result, sep);
	return (result);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_divide_str.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lidbaha <lidbaha@student.42lehavre.fr>     +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/13 21:37:08 by lidbaha           #+#    #+#             */
/*   Updated: 2025/05/13 21:38:09 by lidbaha          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../core/minishell.h"

int	is_separator_at(char *line, char *sep, int pos)
{
	int	i;

	i = 0;
	while (sep[i] != '\0')
	{
		if (line[pos + i] != sep[i])
			return (0);
		i++;
	}
	return (1);
}

int	divide_size_str(char *line, char *sep)
{
	int	i;
	int	result;
	int	sep_len;

	i = 0;
	result = 0;
	sep_len = ft_strlen(sep);
	if (sep_len == 0)
		return (0);
	while (line[i] != '\0')
	{
		if (line[i] == '\"' || line[i] == '\'')
			i = check_quote_closed(line, i + 1, line[i]) + 1;
		else if (is_separator_at(line, sep, i) && !is_separator_at(line, sep, i + sep_len))
		{
			result++;
			i += sep_len - 1;
		}
		else
			i++;
	}
	return (result);
}

char	*add_sep_str(char *sep)
{
	char	*result;
	int		len;
	int		i;

	len = ft_strlen(sep);
	result = malloc(sizeof(char) * (len + 1));
	if (!result)
		return (NULL);
	i = 0;
	while (sep[i])
	{
		result[i] = sep[i];
		i++;
	}
	result[i] = '\0';
	return (result);
}

char	*add_chunk_str(char *line, int start, int end)
{
	char	*chunk;
	int		i;

	i = 0;
	chunk = malloc(sizeof(char) * (end - start + 2));
	if (!chunk)
		return (NULL);
	while (start <= end)
	{
		chunk[i] = line[start];
		i++;
		start++;
	}
	chunk[i] = '\0';
	return (chunk);
}

void	divide_str(char *line, char **result, char *sep)
{
	int	i;
	int	start;
	int	index;
	int	sep_len;

	i = 0;
	start = 0;
	index = 0;
	sep_len = ft_strlen(sep);
	while (line[i] != '\0')
	{
		if (line[i] == '\"' || line[i] == '\'')
			i = check_quote_closed(line, i + 1, line[i]) + 1;
		else if (is_separator_at(line, sep, i) && !is_separator_at(line, sep, i + sep_len))
		{
			result[index] = add_chunk_str(line, start, i - 1);
			result[index + 1] = add_sep_str(sep);
			start = i + sep_len;
			index += 2;
			i += sep_len - 1;
		}
		else
			i++;
	}
	if (start < i)
	{
		result[index] = add_chunk_str(line, start, i - 1);
		index++;
	}
	result[index] = NULL;
}

char	**ft_divide_str(char *line, char *sep)
{
	char	**result;

	result = malloc(sizeof(char *) * (divide_size_str(line, sep) * 2 + 2));
	if (!result)
		return (NULL);
	divide_str(line, result, sep);
	return (result);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parsing_quotes.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lidbaha <lidbaha@student.42lehavre.fr>     +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/01 13:57:22 by lidbaha           #+#    #+#             */
/*   Updated: 2025/04/01 13:57:52 by lidbaha          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../core/minishell.h"

void	add_quote(t_quotes *head, char *line, int index)
{
	t_quotes	*temp;

	if (head->line == NULL)
	{
		head->line = ft_strdup(line);
		head->index = index;
		head->next = NULL;
		return ;
	}
	temp = head;
	while (temp->next != NULL)
		temp = temp->next;
	temp->next = malloc(sizeof(t_quotes));
	temp->next->line = ft_strdup(line);
	temp->next->index = index;
	temp->next->next = NULL;
}

char	*remove_q(char *line, int i, int j)
{
	char	*tmp;
	int		k;

	k = 0;
	tmp = malloc(sizeof(char) * (ft_strlen(line) - (j - i)));
	while (k < i)
	{
		tmp[k] = line[k];
		k++;
	}
	while (line[j] != '\0')
	{
		tmp[k] = line[j];
		k++;
		j++;
	}
	tmp[k] = '\0';
	return (tmp);
}

char	*remove_quotes(char *line, t_quotes *quotes)
{
	int			i;
	int			j;
	int			index;
	t_quotes	*head;

	i = 0;
	index = 0;
	head = quotes;
	while (line[i] != '\0')
	{
		if (line[i] == '\'' || line[i] == '\"')
		{
			j = i + 1;
			while (line[j] != '\0' && line[j] != line[i])
				j++;
			if (line[j] == '\0')
				break ;
			add_quote(head, ft_substr(line, i, j - i + 1), index + i);
			line = remove_q(line, i, j + 1);
			index += j - i + 1;
			i = -1;
		}
		i++;
	}
	return (line);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   replace_quotes.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lidbaha <lidbaha@student.42lehavre.fr>     +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/02 14:32:22 by lidbaha           #+#    #+#             */
/*   Updated: 2025/04/02 14:32:52 by lidbaha          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../core/minishell.h"

/*void	replace_space(char *line, t_parse_space *space, t_quotes *quotes)
{

}

void	replace_redir(char **line, t_quotes *quotes)
{
	int			i;
	int			j;
	int			index;

	i = 0;
	index = 0;
	while (line[i] != NULL)
	{
		j = 0;
		while (line[i][j] != '\0')
		{
			if (quotes->index == index)
			{

			}
			j++;
			index++;
		}
		i++;
		index++;
	}
}

void	replace_quotes(t_parse *cmd, t_quotes *quotes)
{
	if (quotes->line == NULL)
		return ;
	//replace_space(cmd->line, cmd->space, quotes);
	//replace_redir();
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_minishell_split_char.c                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lidbaha <lidbaha@student.42lehavre.fr>     +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/26 18:26:36 by lidbaha           #+#    #+#             */
/*   Updated: 2025/03/26 19:34:07 by lidbaha          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../core/minishell.h"

static int	count_word(const char *s, char c)
{
	int	i;
	int	count;

	i = 0;
	count = 0;
	while (s[i] != '\0')
	{
		if (s[i] == c && s[i + 1] == c)
		{
			i += 2;
			continue ;
		}
		while (s[i] == c)
			i++;
		if (s[i] != '\0' && s[i] != c)
		{
			while (s[i] != '\0' && (s[i] != c || (s[i] == c && s[i + 1] == c)))
				i++;
			count++;
		}
	}
	return (count);
}

static int	skip_double_sep(const char *s, char c, int i)
{
	if (s[i] == c && s[i + 1] == c)
		return (i + 2);
	return (i);
}

static int	fill_tab(char **tab, const char *s, char c, int *i, int y)
{
	int	start;

	while (s[*i] && s[*i] == c)
		(*i)++;
	start = *i;
	while (s[*i] && (s[*i] != c || (s[*i] == c && s[*i + 1] == c)))
		*i = skip_double_sep(s, c, *i) + 1;
	if (*i > start)
	{
		tab[y] = ft_substr(s, start, *i - start);
		if (!tab[y])
			return (0);
	}
	return (1);
}

static int	ft_copy_str_tab(char **tab, const char *s, char c)
{
	int	i;
	int	y;

	i = 0;
	y = 0;
	while (s[i])
	{
		if (!fill_tab(tab, s, c, &i, y))
		{
			free_tab(tab, y - 1);
			return (0);
		}
		y++;
	}
	tab[y] = NULL;
	return (1);
}

char	**ft_minishell_split_char(const char *s, char c)
{
	char	**tab;

	if (!s)
		return (NULL);
	tab = malloc((count_word(s, c) + 1) * sizeof(char *));
	if (!tab)
		return (NULL);
	if (!ft_copy_str_tab(tab, s, c))
		return (NULL);
	return (tab);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_minishell_split_str.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lidbaha <lidbaha@student.42lehavre.fr>     +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/26 17:58:52 by lidbaha           #+#    #+#             */
/*   Updated: 2025/03/29 06:16:21 by lidbaha          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../core/minishell.h"

static int	count_word(const char *s, char *sep)
{
	int		count;
	size_t	sep_len;

	count = 0;
	sep_len = ft_strlen(sep);
	while (*s)
	{
		while (*s && ft_strncmp(s, sep, sep_len) == 0)
			s += sep_len;
		if (*s)
		{
			count++;
			while (*s && ft_strncmp(s, sep, sep_len) != 0)
				s++;
		}
	}
	return (count);
}

static char	*copy_str(const char *s, int start, int end)
{
	return (ft_substr(s, start, end - start));
}

static int	ft_copy_str_tab(char **tab, const char *s, char *sep)
{
	int			i;
	const char	*next_sep;

	i = 0;
	while (*s)
	{
		while (*s && ft_strncmp(s, sep, ft_strlen(sep)) == 0)
			s += ft_strlen(sep);
		if (*s)
		{
			next_sep = strstr(s, sep);
			if (!next_sep)
				next_sep = s + ft_strlen(s);
			tab[i] = copy_str(s, 0, next_sep - s);
			if (!tab[i])
				return (free_tab(tab, i - 1), 0);
			i++;
			s = next_sep;
		}
	}
	tab[i] = NULL;
	return (1);
}

char	**ft_minishell_split_str(const char *s, char *sep)
{
	char	**tab;

	if (!s || !sep)
		return (NULL);
	tab = malloc((count_word(s, sep) + 1) * sizeof(char *));
	if (!tab)
		return (NULL);
	if (!ft_copy_str_tab(tab, s, sep))
		return (NULL);
	return (tab);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strdup_split.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lidbaha <lidbaha@student.42lehavre.fr>     +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/25 15:07:13 by lidbaha           #+#    #+#             */
/*   Updated: 2025/03/25 15:27:59 by lidbaha          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../core/minishell.h"

int	ft_split_len(char **split)
{
	int	i;

	i = 0;
	while (split[i])
		i++;
	return (i);
}

char	**ft_strdup_split(char **split)
{
	char	**new;
	int		i;

	if (!split)
		return (NULL);
	new = malloc(sizeof(char *) * (ft_split_len(split) + 1));
	if (!new)
		return (NULL);
	i = 0;
	while (split[i])
	{
		new[i] = ft_strdup(split[i]);
		if (!new[i])
		{
			clean_split(new);
			return (NULL);
		}
		i++;
	}
	new[i] = NULL;
	return (new);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   toto_t_fill.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmillot <tmillot@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/17 10:48:05 by tmillot           #+#    #+#             */
/*   Updated: 2025/05/17 20:48:26 by tmillot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../core/minishell.h"

void add_back_t_redir(t_redir **redirection, char *file, t_token_type type)
{
	t_redir		*new;
	t_redir		*current;

	new = malloc(sizeof(t_redir));
	if (type == HEREDOC)
		new->file = get_here_doc(file);
	else
		new->file = ft_strdup(file);
	new->type = type;
	new->next = NULL;
	current = *redirection;
	if (*redirection == NULL)
		*redirection = new;
	else
	{
		while (current->next != NULL)
			current = current->next;
		current->next = new;
	}
}

char	**list_to_array_char(t_list *lst)
{
	int		size;
	char	**tab;
	int		i;

	size = ft_lstsize(lst);
	i = 0;
	tab = malloc(sizeof(char *) * (size + 1));
	while (lst != NULL)
	{
		tab[i++] = lst->content;
		lst = lst->next;
	}
	tab[i] = NULL;
	return (tab);
}

void	fill_t_cmd(t_parse_redir *redir, t_cmd *cmd)
{
	int				i;
	t_parse_redir	*current_redir;
	t_list			*args;
	t_cmd			*current_cmd;

	current_redir = redir;
	current_cmd = cmd;
	args = NULL;
	while (current_redir != NULL)
	{
		i = 0;
		while (current_redir->line[i] != NULL)
		{
			if (ft_strncmp(current_redir->line[i], "<", 1) == 0)
			{
				add_back_t_redir(&current_cmd->infile, current_redir->line[i + 1], REDIRECT_IN);
				i += 2;
			}
			else if (ft_strncmp(current_redir->line[i], ">", 1) == 0)
			{
				add_back_t_redir(&current_cmd->outfile, current_redir->line[i + 1], REDIRECT_OUT);
				i += 2;
			}
			else if (ft_strncmp(current_redir->line[i], "<<", 2) == 0)
			{
				add_back_t_redir(&current_cmd->infile, current_redir->line[i + 1], HEREDOC);
				i += 2;
			}
			else if (ft_strncmp(current_redir->line[i], ">>", 2) == 0)
			{
				add_back_t_redir(&current_cmd->outfile, current_redir->line[i + 1], REDIRECT_APPEND);
				i += 2;
			}
			else
			{
				ft_lstadd_back(&args, ft_lstnew(ft_strdup(current_redir->line[i])));
			}
			current_cmd->args = list_to_array_char(args);
			ft_lstclear(&args, free);
			args = NULL;
			i++;
		}
		if (current_redir->next != NULL)
		{
			current_cmd->next = init_cmd();
			current_cmd = current_cmd->next;
		}
		else
			current_cmd->next = NULL;
		current_redir = current_redir->next;
	}
}
